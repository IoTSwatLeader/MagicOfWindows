<#=========================================================================================
Files:     Update_WinRE_CVE-2022-41099.ps1

Summary:
This script is intended to update the local WinRE regarding CVE-2022-41099.

Official verison of Brandon Halsey
https://github.com/halsey51013/UpdateWindowsRE-CVE-2022-41099/blob/main/UpdateWindowsRE.ps1

Version	    Date		Author				Description
-------------------------------------------------------------------------------------------
    1.0     2023-02-23
            2023-02-24	Juergen Kutschera	Script created
    1.1     2023-02-27  Juergen Kutschera   Updates to remove REAGENTC calls
                                            Updates to reduce DISM calls
    1.2     2023-02-28  Juergen Kutschera   Updates to Invoke-UpdateWinRE, Invoke-TPMHashUpdate
                                            Implementing Invoke-Process
                                            Adding Offline Path Capabilities

-------------------------------------------------------------------------------------------
DISCLAIMER:

This Sample Code is provided for the purpose of illustration only and is not intended to 
be used in a production environment.

THIS SAMPLE CODE AND ANY RELATED INFORMATION ARE PROVIDED AS IS
WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.


We grant You a nonexclusive, royalty-free right to use and modify the Sample Code
and to reproduce and distribute the object code form of the Sample Code, provided
that You agree:
(i)	to not use Our name, logo, or trademarks to market Your software
        product in which the Sample Code is embedded; 
(ii)	to include a valid copyright notice on Your software product in which 
        the Sample Code is embedded; and 
(iii)	to indemnify, hold harmless, and defend Us and Our suppliers from and 
        against any claims or lawsuits, including attorneys' fees, that arise 
        or result from the use or distribution of the Sample Code.

Please note: None of the conditions outlined in the disclaimer above will supersede terms 
             and conditions contained within the Premier Customer Services Description.


ALL CODE MUST BE TESTED BY ANY RECIPIENTS AND SHOULD NOT BE RUN IN A PRODUCTION ENVIRONMENT 
WITHOUT MODIFICATION BY THE RECIPIENT.

CODE CHANGES ARE NOT PERMITTED. EXPLICIT ALLOWANCE MUST BE GRANTED!

=========================================================================================
EXAMPLE: 
powershell.exe -file Update_WinRE_CVE2022-41099.ps1
=========================================================================================#>

#Description: Writes a message including Timestamp and Severity to a log file
#Function Data:
#   Name:           Write-Log
#   Parameters:     LogFile, Classification, Level, Message
#   Returns:        None
Function Write-Log 
{
    <#
        .SYNOPSIS
        Write Log File

        .DESCRIPTION
        Writes a message including Timestamp and Severity to a log file.

        .PARAMETER Classification
        Specifies the Classification of the Message.
        Possible Values: IMPORTANT, INFO, DEBUG

        .PARAMETER Level
        Specifies the Severity of the Message.
        Possible Values: INFO, WARN, ERROR, FATAL, DEBUG, TRACE

        .PARAMETER LogFile
        Specifies the LogFile Path

        .PARAMETER Message
        Specifies the Message

        .EXAMPLE
        Write-Log -Message "Text" -Classification INFO

        .EXAMPLE
        Write-Log -Message "Text" -Classification INFO -LogFile "%Temp%\Logfile.log"
    #>

    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$False)]
        [string]
        $LogFile = $global:LogFilePath,

        [Parameter(Mandatory=$False)]
        [ValidateSet("INFO","WARN","ERROR","FATAL","DEBUG","TRACE")]
        [String]
        $Level = "INFO",

        [Parameter(Mandatory=$True)]
        [string]
        $Message
    )

    #Internal Declarations and Definition Updates
    $Stamp        = (Get-Date).toString("yyyy/MM/dd HH:mm:ss")
    $HeaderString = "Timestamp".PadRight(22, ' ') + "Level".PadRight(10, ' ') + "Message".PadRight(60,' ')
    $LineString   = $Stamp.PadRight(22, ' ') + $Level.PadRight(10, ' ') + $Message.PadRight(60,' ')

    #Verify if Log File already exists
    If(Test-Path $LogFile) 
    {
        #Writing to Log File
        Add-Content -Path $LogFile -Value $LineString
    }
    Else 
    {
        #Writing to Log File including Header Line
        Add-Content -Path $LogFile -Value $HeaderString
        Add-Content -Path $LogFile -Value $LineString
    }

    #Writing to Debug Window
    if($global:DebugMode)
    {
        Write-Host $LineString
    }
}

#Description: Debug output of WinRE details
#Function Data:
#   Name:           Write-WinReDebugOutput 
#   Parameters:     WinRE
#   Returns:        None
Function Write-WinReDebugOutput 
{
    <#
        .SYNOPSIS
        Debug output of WinRE details

        .DESCRIPTION
        Debug output of WinRE details

        .PARAMETER WinRE
        Data to output

        .EXAMPLE
        Write-WinReDebugOutput -WinRE $WinRE_Current
    #>

    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True)]
        $WinRE
    )

    Write-Log -Level INFO -Message "WinRE.WIM File Information"
    Write-Log -Level INFO -Message " -> Path     : $($WinRE.ImagePath)"
    Write-Log -Level INFO -Message " -> Status   : $($WinRE.Enabled)"
    Write-Log -Level INFO -Message " -> Version  : $($WinRE.Version)"
    Write-Log -Level INFO -Message " -> Modified : $($WinRE.ModifiedTime)"
}

#Description: Test for exit conditions
#Function Data:
#   Name:           Test-ExitConditions
#   Parameters:     None
#   Returns:        Boolean
#                   True  = Success
#                   False = Failure
Function Test-ExitConditions
{
    <#
        .SYNOPSIS
        Test for exit conditions

        .DESCRIPTION
        Test for exit conditions

        .EXAMPLE
        Test-ExitConditions
    #>

    #Exit Condition for non-64bit Systems
    if (![Environment]::Is64BitOperatingSystem) 
    {
        Write-Log -Level ERROR -Message "<Exit Condition> failed"
        Write-Log -Level ERROR -Message " -> OS is not 64bit. The procedure is intended for 64 bit OS only."
        return [boolean]$false
    }

    #Exit Condition for Reboot Required
    if((Test-Path -Path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired') `
        -or (Test-Path -Path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending') )
    {
        Write-Log -Level ERROR -Message "<Exit Condition> failed"
        Write-Log -Level ERROR -Message " -> Computer has pending reboot or pending update."
        Write-Log -Level ERROR -Message " -> Unable to update WinRE until the computer is rebooted."
        return [boolean]$false
    }    

    #Exit Success
    return [boolean]$true
}

#Description: Add an update entry
#Function Data:
#   Name:           Add-UpdatePaths
#   Parameters:     OSVersion
#                   OSDescription
#                   KBCU
#                   URICU
#                   KBSafeOS
#                   URISafeOSUpdate
#   Returns:        Custom PSObject
Function Add-UpdatePaths
{
    <#
        .SYNOPSIS
        Add a update entry

        .DESCRIPTION
        Add a update entry

        .PARAMETER OSVersion
        Build version of Operating System

        .PARAMETER OSDescription
        Description of Operating System

        .PARAMETER KBCU
        KB for cumulative update

        .PARAMETER URICU
        Download path of cumulative update

        .PARAMETER KBSafeOS
        KB for SafeOS update

        .PARAMETER URISafeOS
        Download path of SafeOS update

        .OUTPUTS
        Custom Object with data

        .EXAMPLE
        Add-UpdatePaths -OSVersion 22621 -KBCU "KB5022303" -URICU <...> -KBSafeOS "KB5022609" -URISafeOS <...>
    #>
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True)]
        [Int32]
        $OSVersion,

        [Parameter(Mandatory=$True)]
        [String]
        $OSDescription,

        [Parameter(Mandatory=$True)]
        [String]
        $KBCU,

        [Parameter(Mandatory=$True)]
        [String]
        $URICU,

        [Parameter(Mandatory=$True)]
        [String]
        $KBSafeOS,

        [Parameter(Mandatory=$True)]
        [String]
        $URISafeOS
    )

    #internal declarations
    $private:update = New-Object PSCustomObject

    #adding the values
    $private:update | Add-Member -type NoteProperty -Name OSVersion -Value ($OSVersion)
    $private:update | Add-Member -type NoteProperty -Name OSDescripiton -Value ($OSDescription)
    $private:update | Add-Member -type NoteProperty -Name KBCU -Value $KBCU
    $private:update | Add-Member -type NoteProperty -Name URICU -Value $URICU
    $private:update | Add-Member -type NoteProperty -Name KBSafeOS -Value $KBSafeOS
    $private:update | Add-Member -type NoteProperty -Name URISafeOS -Value $URISafeOS

    #Return Data
    return $private:update
}

#Description: Get the update entry
#Function Data:
#   Name:           Get-UpdatePath
#   Parameters:     UpdatesAvailable
#                   OSVersion
#   Returns:        Custom PSObject
Function Get-UpdateEntry
{
    <#
        .SYNOPSIS
        Get the update entry

        .DESCRIPTION
        Get the update entry

        .PARAMETER UpdatesAvailable
        All available updates

        .PARAMETER OSVerison
        Operating System to search ofr

        .OUTPUTS
        Custom Object with data

        .EXAMPLE
        Get-UpdateEntry -UpdateAvailable <variable> -OSVersion "10.0.22621"
    #>
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True)]
        $UpdatesAvailable,

        [Parameter(Mandatory=$True)]
        [Int32]
        $OSVersion
    )

    #search for the OSVersion
    foreach($update in $UpdatesAvailable)
    {
        if ($update.OSVersion -eq $OSVersion)
        {
            return $update
        }
    }

    #Return Data
    return New-Object PSCustomObject
}

#Description: Add an update entry
#Function Data:
#   Name:           Add-UpdatePaths
#   Parameters:     OSVersion
#                   OSDescription
#                   KBCU
#                   URICU
#                   KBSafeOS
#                   URISafeOSUpdate
#   Returns:        Custom PSObject
Function Get-WinREData
{
    <#
        .SYNOPSIS
        Get data of WinRE.WIM file

        .DESCRIPTION
        Get data of WinRE.WIM file

        .OUTPUTS
        Custom Object with data

        .EXAMPLE
        Get-WinREData
    #>

    #internal declarations
    $private:winre = New-Object PSCustomObject

    #get WinRE.wim information
    if (-NOT (Test-Path "$env:SystemRoot\System32\Recovery\ReAgent.xml")) {
        Write-Warning "Unable to find $env:SystemRoot\System32\Recovery\ReAgent.xml"
    }
    else 
    {
        [xml]$XmlDocument = Get-content -Path "$env:SystemRoot\System32\Recovery\ReAgent.xml" -Raw
        $XmlDocument.SelectNodes('WindowsRE') | ForEach-Object {
            $local:WinRE_LocationId = $_.WinreLocation.id
            $local:WinRE_LocationOffset = $_.WinreLocation.offset
            $local:WinRE_LocationPath = $_.WinreLocation.path
            $local:WinRE_LocationPartition = (Get-Disk -Number $local:WinRE_LocationId | Get-Partition | Where-Object {$_.Offset -eq $local:WinRE_LocationOffset}).PartitionNumber
            $WinRE_InstallState = $_.InstallState.state
            $WinRE_Enabled = if ($WinRE_InstallState -eq 0) { $false } else { $true }
            $WinRE_IsAutoRepairOn = $_.IsAutoRepairOn.state
            $WinRE_OsBuildVersion = $_.OsBuildVersion.path
            $WinRE_Location = '\\?\GLOBALROOT\device\harddisk' + $local:WinRE_LocationId + '\partition' + $local:WinRE_LocationPartition + $local:WinRE_LocationPath
        }

        #adding the values
        $local:WinREData = (Get-WindowsImage -imagepath (($WinRE_Location).TRIM() + "\winre.wim") -index 1)
        $private:winre | Add-Member -type NoteProperty -Name Enabled -Value $WinRE_Enabled
        $private:winre | Add-Member -type NoteProperty -Name Build -Value $local:WinREData.SPBuild
        $private:winre | Add-Member -type NoteProperty -Name AutoRepairOn -Value $WinRE_IsAutoRepairOn
        $private:winre | Add-Member -type NoteProperty -Name Version -Value $local:WinREData.Version
        $private:winre | Add-Member -type NoteProperty -Name ModifiedTime -Value $local:WinREData.ModifiedTime
        $private:winre | Add-Member -type NoteProperty -Name CreatedTime -Value $local:WinREData.CreatedTime
        $private:winre | Add-Member -type NoteProperty -Name OsBuildVersion -Value $WinRE_OsBuildVersion
        $private:winre | Add-Member -type NoteProperty -Name ImagePath -Value $local:WinREData.ImagePath
        $private:winre | Add-Member -type NoteProperty -Name ImageName -Value $local:WinREData.ImageName
    }

    #Return Data
    return $private:winre
}

#Description: Download the required update
#Function Data:
#   Name:           Invoke-DownloadUpdate
#   Parameters:     UpdatePackage
#                   LocalUpdateFile
#   Returns:        Boolean
#                   True  = Success
#                   False = Failure
Function Invoke-DownloadUpdate
{
    <#
        .SYNOPSIS
        Download the required update

        .DESCRIPTION
        Download the required update

        .PARAMETER UpdatePackage
        Update package details

        .PARAMETER LocalUpdateFile
        Local update file

        .EXAMPLE
        Invoke-DownloadUpdate -UpdatePackage $Update
    #>

    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True)]
        $UpdatePackage,

        [Parameter(Mandatory=$True)]
        [string]
        $LocalUpdateFile
    )

    #Internal declaration
    $OfflinePackageFound = $false
    $OfflineFileName = [String]::Empty

    #Set the action preference
    $ProgressPreference = 'SilentlyContinue'  
    try 
    {
        #Try offline mode if available
        if($global:PriorizedOfflineMode)
        {
            if($global:DeploymentModeSafeOS)
            {
                #Using Offline SafeOS Package
                Write-Log -Level INFO -Message " -> Searching for Offline SafeOS Update <$($UpdatePackage.KBSafeOS)> in path <$($global:PriorizedOfflinePath)>"
                $OfflineFileName = (Get-ChildItem -Path $global:PriorizedOfflinePath | Where-Object Name -like "*$($UpdatePackage.KBSafeOS)*").FullName
            }
            else 
            {
                #Using Offline CU Package
                Write-Log -Level INFO -Message " -> Searching for Offline Cumulative Update Update <$($UpdatePackage.KBCU)> in path <$($global:PriorizedOfflinePath)>"
                $OfflineFileName = (Get-ChildItem -Path $global:PriorizedOfflinePath | Where-Object Name -like "*$($UpdatePackage.KBCU)*").FullName
            }

            if($OfflineFileName -ne $null)
            {
                #File Found
                Write-Log -Level INFO -Message "    -> Update package detected <$($OfflineFileName)>"
                $global:DownloadFile = $OfflineFileName
                $OfflinePackageFound = $true
            }
            else 
            {
                #File Not Found
                Write-Log -Level FATAL -Message "    -> Update package not found"
            }
        }

        if(($PriorizedOfflineMode -and $OfflinePackageFound -eq $False) -or !$PriorizedOfflineMode)
        {
            #Download the required update package
            if($global:DeploymentModeSafeOS)
            {
                #Downloading SafeOS Package
                Write-Log -Level INFO -Message " -> Downloading SafeOS Update <$($UpdatePackage.KBSafeOS)>"
                $WebRequestResult = Invoke-WebRequest -Uri $UpdatePackage.URISafeOS -OutFile $DownloadFile -UseBasicParsing -PassThru
            }
            else
            {
                #Downloading Cumulate Update Package
                Write-Log -Level INFO -Message " -> Downloading Cumulative Update <$($UpdatePackage.KBCU)>"
                $WebRequestResult = Invoke-WebRequest -Uri $UpdatePackage.URICU -OutFile $DownloadFile -UseBasicParsing -PassThru   
            }
            if($WebRequestResult.StatusCode -eq 200 )
            {
                Write-Log -Level INFO -Message "    -> Downloaded update package successfully <$($DownloadFile)>"
            } 
            else 
            {
                throw "Failed to download update package (Status $($WebRequestResult.StatusCode))"
            }
        }
    }
    catch [System.Net.WebException], [System.IO.IOException] 
    {
        #Exit Failure
        Write-Log -Level FATAL -Message " -> Web / IO Exception: $($_)"    
        return [boolean]$false
    }
    catch 
    {
        #Exit Failure
        Write-Log -Level FATAL -Message " -> Generic ERROR: $($_)"
        return [boolean]$false
    }

    #Exit Success
    return [boolean]$true
}

#Description: Mount the WinRE offline image
#Function Data:
#   Name:           Invoke-MountWinRE
#   Parameters:     WinREPath
#                   MountDir
#                   UpdateFile
#                   UpdatePackage
#   Returns:        Boolean
#                   True  = Success
#                   False = Failure
Function Invoke-UpdateWinRE
{
    <#
        .SYNOPSIS
        Mount the WinRE offline image

        .DESCRIPTION
        Mount the WinRE offline image

        .PARAMETER WinREPath
        WinRE settings

        .PARAMETER MountDir
        MountPoint for offline image

        .PARAMETER UpdateFile
        Path to the update file

        .PARAMETER UpdatePackage
        Update package details

        .EXAMPLE
        Invoke-MountWinRE WinREPath <path to WinRE.WIM>
    #>

    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True)]
        [string]
        $WinREPath,

        [Parameter(Mandatory=$True)]
        [string]
        $MountDir,

        [Parameter(Mandatory=$True)]
        [string]
        $UpdateFile,

        [Parameter(Mandatory=$True)]
        $UpdatePackage
    )

    #Set the action preference
    $ProgressPreference = 'SilentlyContinue'        

    try 
    {
        #Check if the local mount point exists
        if (!(Test-Path -PathType Container -Path $MountDir)) 
        { 
            #Create new directory if not existing
            Write-Log -Level INFO -Message " -> Creating mount point <$($MountDir)>"
            New-Item -ItemType Directory -Path $MountDir -Force | Out-Null
        }

        #Mount the WinRE offline image
        if((Invoke-Process -Path ReAgentC.exe -Arguments "/mountre /path $($MountDir)") -eq 0)
        {
            Write-Log -Level INFO -Message "    -> Mounting Windows RE successful"
        } 
        else 
        {
            throw "    -> Mounting Windows RE Image Failed. Output: $REMountResult"
        }

        #Validate the Update Status
        $KB = ""
        if ($global:DeploymentModeSafeOS)
        {
            $KB = $UpdatePackage.KBSafeOS
        }
        else 
        {
            $KB = $UpdatePackage.KBCU    
        }
        $UpdateStatus = Get-WindowsPackage -Path $MountDir | Where-Object -Property PackageName -like "*$($KB)*" | Where-Object -Property PackageState -eq "Installed"
        Write-Log -Level INFO -Message " -> Installed packages for <$($KB)> found: $($UpdateStatus.Count)"
		if($UpdateStatus.Count -eq 0)
        {
            #Add the update package
            Write-Log -Level INFO -Message " -> Running DISM Add-Package"
            try 
            {
                Add-WindowsPackage -Path "$($MountDir)" -PackagePath "$($UpdateFile)" -NoRestart
                Write-Log -Level INFO -Message "    -> DISM Add-Package Successful"
            }
            catch
            {
                Write-Log -Level INFO -Message "    -> DISM Add-Package Failed."
            }

            #Run Cleanup-Image command
            Write-Log -Level INFO -Message " -> Running DISM Cleanup-Image" 
            Write-Log -Level INFO -Message "    -> Sleeping 5s to prevent DISM Error 0x800f0823" #https://www.reddit.com/r/sysadmin/comments/10a1enh/how_are_you_updating_winre_to_address_cve202241099/j480gos/
            Start-Sleep -Seconds 5
            if(Invoke-Process -Path "Dism.exe" -Arguments "/image:$($MountDir) /cleanup-image /StartComponentCleanup /ResetBase" -eq 0)
            {
                Write-Log -Level INFO -Message "    -> DISM Cleanup-Image Successful"
            }
            else 
            {
                throw "    -> DISM Cleanup-Image Failed"
            }  

            #Unmount the WinRE offline image
            Write-Log -Level INFO -Message " -> Dismounting and Saving Windows RE" 
            Write-Log -Level INFO -Message "    -> Sleeping 5s to prevent DISM Error 0x800f0823" #https://www.reddit.com/r/sysadmin/comments/10a1enh/how_are_you_updating_winre_to_address_cve202241099/j480gos/
            Start-Sleep -Seconds 5
            Write-Log -Level INFO -Message "    -> Dismounting Windows RE image"
            Dismount-WindowsImage -Path $MountDir -Save -CheckIntegrity
        }  
        else 
        {
            Write-Log -Level INFO -Message "    -> Update not required"  
            
            #Unmount the WinRE offline image
            Write-Log -Level INFO -Message " -> Dismounting and Discarding Windows RE"
            Dismount-WindowsImage -Path $MountDir -Discard
        }
    }    
    catch 
    {
        #Exit Failure
        Write-Log -Level FATAL -Message "    -> Generic ERROR: $($_)"
        return [boolean]$false
    }

    #Exit Success
    return [boolean]$true
}

#Description: Invoke running a process
#Function Data:
#   Name:           Invoke-Process
#   Parameters:     Path, Parameter
#   Returns:        Exit Code
Function Invoke-Process
{
    <#
        .SYNOPSIS
        Invoke running a process

        .DESCRIPTION
        Invoke running a process

        .PARAMETER Path
        Name of the Process

        .PARAMETER Arguments
        Arguments for the call

        .EXAMPLE
        Invoke-Process -Path <name of process> -Arguments <parameters>
    #>

    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True)]
        [string]
        $Path,

        [Parameter(Mandatory=$True)]
        [string]
        $Arguments
    )

    #Set the action preference
    $ProgressPreference = 'SilentlyContinue'  

    #Internal declarations
    $pinfo = New-Object System.Diagnostics.ProcessStartInfo
    $p = New-Object System.Diagnostics.Process

    #Process Parameters
    $pinfo.FileName = $Path
    $pinfo.RedirectStandardError = $True
    $pinfo.RedirectStandardInput = $True
    $pinfo.RedirectStandardOutput = $True
    $pinfo.LoadUserProfile        = $False
    $pinfo.UseShellExecute = $false
    $pinfo.WindowStyle = 'Hidden'
    $pinfo.Arguments = $Arguments    
    $p.StartInfo = $pinfo

    #Start and Wait for Process
    $p.Start() | Out-Null    
    $p.WaitForExit()

    #Return the ExitCode
    return $p.ExitCode
}

#Description: Update the TPM hash for WinRE image
#Function Data:
#   Name:           Invoke-TPMHashUpdate
#   Parameters:     none
#   Returns:        Boolean
#                   True  = Success
#                   False = Failure
Function Invoke-TPMHashUpdate
{
    <#
        .SYNOPSIS
        Update the TPM hash for WinRE image

        .DESCRIPTION
        Update the TPM hash for WinRE image

        .PARAMETER none
        none

        .EXAMPLE
        Invoke-TPMHashUpdate
    #>

    #Set the action preference
    $ProgressPreference = 'SilentlyContinue'  

    #Local Declarations
    $Tasks = @(
        [PSCustomObject]@{Name = 'Disable';  CommandParam = '/disable'}
        [PSCustomObject]@{Name = 'Enable';   CommandParam = '/enable'}
    )   

    #Update the WinRE hash in TPM
    try 
    {
        #Update the WinRE hash in TPM 
        Write-Log -Level INFO -Message "Updating the TPM Hash for WinRE"
        foreach($Task in $Tasks)
        {
            Write-Log -Level INFO -Message " -> $($Task.Name) WinRE"
            
            if((Invoke-Process -Path "reagentc.exe" -Arguments $Task.CommandParam) -eq 0)
            {
                Write-Log -Level INFO -Message "     -> Success"
            }
            else 
            {
                Write-Log -Level INFO -Message "     -> Failed (ExitCode=$($ProcessDetails.ExitCode))"    
            }
        }
    }
    catch 
    {
        #Exit Failure
        Write-Log -Level FATAL -Message " -> Generic ERROR: $($_)"
        return [boolean]$false
    }

    #Exit Success
    return [boolean]$true
}

##################################################################################################################
####                                    P R O G R A M    P A R A M E T E R S                                  ####
##################################################################################################################

#Debug Mode
$global:DebugMode               = [Boolean]$true

#DeploymentMode
$global:DeploymentModeSafeOS    = [Boolean]$true            #$true = SafeOS update, $false = full cumulative update

#OfflineMode
$global:PriorizedOfflineMode    = [Boolean]$true            #$true = offline SafeOS update - if not available CDN Download, $false = download from CDN depending on DeploymentModeSafeOS value
$global:PriorizedOfflinePath    = $PSScriptRoot             #Path of the offline files  

#Log File
$global:LogFilePath             = [System.Environment]::ExpandEnvironmentVariables("%TEMP%\Update-WinRE-CVE-2022-41099.log")

#Temporary Data
$MountDir                       = [System.Environment]::ExpandEnvironmentVariables("%SYSTEMDRIVE%\MOUNT")
$DownloadFile                   = [System.Environment]::ExpandEnvironmentVariables("%TEMP%\Update_WinRE.cab")

#Available Updates for CVE-2022-41099
$global:Updates = @()
$global:Updates += Add-UpdatePaths -OSVersion 22621 -OSDescription "Windows 11 22H2 - Build 22621" -KBCU "KB5022303" -URICU "https://catalog.s.download.windowsupdate.com/d/msdownload/update/software/crup/2023/01/windows11.0-kb5022609-x64_1f5e0fd80fdd08e541903b0d2d845d5b88bee2b4.cab" -KBSafeOS "KB5022609" -URISafeOS "https://catalog.s.download.windowsupdate.com/d/msdownload/update/software/crup/2023/01/windows11.0-kb5022609-x64_1f5e0fd80fdd08e541903b0d2d845d5b88bee2b4.cab"
$global:Updates += Add-UpdatePaths -OSVersion 22000 -OSDescription "Windows 11 21H2 - Build 22000" -KBCU "KB5022287" -URICU "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021040-x64_2216fe185502d04d7a420a115a53613db35c0af9.cab" -KBSafeOS "KB5021040" -URISafeOS "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021040-x64_2216fe185502d04d7a420a115a53613db35c0af9.cab"
$global:Updates += Add-UpdatePaths -OSVersion 19045 -OSDescription "Windows 10 22H2 - Build 19045" -KBCU "KB5022282" -URICU "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021043-x64_efa19d2d431c5e782a59daaf2d04d026bb8c8e76.cab" -KBSafeOS "KB5021043" -URISafeOS "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021043-x64_efa19d2d431c5e782a59daaf2d04d026bb8c8e76.cab"
$global:Updates += Add-UpdatePaths -OSVersion 19044 -OSDescription "Windows 10 21H2 - Build 19044" -KBCU "KB5022282" -URICU "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021043-x64_efa19d2d431c5e782a59daaf2d04d026bb8c8e76.cab" -KBSafeOS "KB5021043" -URISafeOS "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021043-x64_efa19d2d431c5e782a59daaf2d04d026bb8c8e76.cab"
$global:Updates += Add-UpdatePaths -OSVersion 19043 -OSDescription "Windows 10 21H1 - Build 19043" -KBCU "KB5021233" -URICU "https://catalog.s.download.windowsupdate.com/d/msdownload/update/software/secu/2022/12/windows10.0-kb5021233-x64_4b20e15fe6e4cf264be4651f95395e8980684a17.cab" -KBSafeOS "KB5021043" -URISafeOS "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021043-x64_efa19d2d431c5e782a59daaf2d04d026bb8c8e76.cab"
$global:Updates += Add-UpdatePaths -OSVersion 19042 -OSDescription "Windows 10 20H2 - Build 19042" -KBCU "KB5022282" -URICU "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021043-x64_efa19d2d431c5e782a59daaf2d04d026bb8c8e76.cab" -KBSafeOS "KB5021043" -URISafeOS "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021043-x64_efa19d2d431c5e782a59daaf2d04d026bb8c8e76.cab"

#Setting Security Protocol for .Net Framework to use TLS1.2...
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

##################################################################################################################
####                                 P R O G R A M    S E Q U E N C E   C O D E                               ####
##################################################################################################################

#Program Start
$Starttime = Get-Date

#Debug Output of Program Start
Write-Log -Level INFO -Message "##################################################################################################################"
Write-Log -Level INFO -Message "####                            P R O G R A M    S E Q U E N C E   S T A R T                                  ####"
Write-Log -Level INFO -Message "##################################################################################################################"
Write-Log -Level INFO -Message "Configuration Parameters"
Write-Log -Level INFO -Message " -> Debug Mode                : $($global:DebugMode)"
Write-Log -Level INFO -Message " -> Priorized Offline Mode    : $($global:PriorizedOfflineMode)"
Write-Log -Level INFO -Message " -> Priorized Offline Path    : $($global:PriorizedOfflinePath)"
Write-Log -Level INFO -Message " -> Deployment SafeOS Package : $($global:DeploymentModeSafeOS)"

#Check for Exit Conditions
if (Test-ExitConditions)
{
    #Debug Output
    Write-Log -Level INFO -Message "<Exit Condition> tests successfully completed..."

    #Get Details of WinRE.WIM file
    $WinRE_Current = Get-WinREData
    Write-WinReDebugOutput -WinRE $WinRE_Current

    #Get Details of OS
    $OSVersion = (Get-CimInstance Win32_OperatingSystem).Version
    $OSBuildNumber = (Get-CimInstance Win32_OperatingSystem).BuildNumber
    Write-Log -Level INFO -Message "Current Operating System"
    Write-Log -Level INFO -Message " -> Version  : $($OSVersion)"

    #Internal Error Handling
    if($WinRE_Current.Enabled)
    {
        try 
        {
            #Get the required update package
            $UpdatePackage = Get-UpdateEntry -UpdatesAvailable $global:Updates -OSVersion $OSBuildNumber

            #Download the required update package
            Write-Log -Level INFO -Message "Download the update package"
            if($UpdatePackage.length -ne 0)
            {
                if(!(Invoke-DownloadUpdate -UpdatePackage $UpdatePackage -LocalUpdateFile $DownloadFile))
                {
                    #Error Handling
                    throw "Aborting WinRE update process"
                }            
            }
            else 
            {
                #Error Handling
                throw "No update available for this system"
            }

            #Update the WinRE.WIM offline image
            Write-Log -Level INFO -Message "Update the local WinRE offline image"
            if(!(Invoke-UpdateWinRE -WinREPath $WinRE_Current.ImagePath -MountDir $MountDir -UpdateFile $DownloadFile -UpdatePackage $UpdatePackage ))
            {
                #Error Handling
                throw "Aborting WinRE update process"
            }

            #Update the WinRE.WIM hash in TPM
            if(!(Invoke-TPMHashUpdate))
            {
                #Error Handling
                throw "Aborting WinRE update process"
            }
        }    
        catch 
        {
            Write-Log -Level FATAL -Message " -> ERROR: $($_)"    
            if (Test-Path -PathType Container -Path ($MountDir + "\Windows")) 
            { 
                Write-Log -Level INFO -Message "Dismounting Windows RE due to it is still mounted. Discarding changes."
                Dismount-WindowsImage -Path $MountDir -Discard
            }
        }    

        #Get Details of WinRE.WIM file
        $WinRE_Updated = Get-WinREData
        Write-WinReDebugOutput -WinRE $WinRE_Updated

        #Clean-up tasks
        Write-Log -Level INFO -Message "Cleaning up files and directories"
        if (Test-Path -PathType Container -Path $MountDir) 
        { 
            Write-Log -Level INFO -Message " -> Removing directory <$($MountDir)>"
            Remove-Item -Path $MountDir -Force 
        }
        if (Test-Path -Path $DownloadFile) 
        { 
            Write-Log -Level INFO -Message " -> Removing downloaded file <$($DownloadFile)>"
            Remove-Item -Path $DownloadFile -Force 
        }
    }
    else 
    {
        Write-Log -Level INFO -Message "Windows Recovery Environment not enabled. No actions required."
    }
}
else
{
    Write-Log -Level FATAL -Message "Abnormal Exit of Script"
}


##################################################################################################################
####                                           P R O G R A M   E N D                                           ###
##################################################################################################################

#Program End
$Endtime = Get-Date
$Duration = $Endtime - $Starttime
Write-Log -Level INFO -Message "Program Sequene End [Duration: $Duration]" 
