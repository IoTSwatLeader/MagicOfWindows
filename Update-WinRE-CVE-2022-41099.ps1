<#=========================================================================================
Files:     Update_WinRE_CVE-2022-41099.ps1

Summary:
This script is intended to update the local WinRE regarding CVE-2022-41099.

Official verison of Brandon Halsey
https://github.com/halsey51013/UpdateWindowsRE-CVE-2022-41099/blob/main/UpdateWindowsRE.ps1

Version	    Date		Author				Description
-------------------------------------------------------------------------------------------
    1.0     2023-02-23
            2023-02-24	Juergen Kutschera	Script created
    1.1     2023-02-27  Juergen Kutschera   Updates to remove REAGENTC calls
                                            Updates to reduce DISM calls
    1.2     2023-02-28  Juergen Kutschera   Updates to Invoke-UpdateWinRE, Invoke-TPMHashUpdate
                                            Implementing Invoke-Process
                                            Adding Offline Path Capabilities
    1.21    2023-03-09  Juergen Kutschera   Adding LTSC versions 2016 and 2019
    1.22    2023-03-22  Anton Romanyuk      Adding exit code logic 
    1.23    2023-03-23  Juergen Kutschera   Adding FixedWithBuild, minor fixes
                                            Changing Test-ExitConditions for already mitigated,
                                            Change flow to process update if winre.wim is available 
                                            (and not only if status is enabled), adding staging info
                                            to Invoke-DownloadUpdate, adding FixedWithBuild property,
                                            Adding check for existing of winre.wim file (Get-WinREData),
                                            Updating exit codes and moving to variables
    1.24    2023-03-30  Juergen Kutschera   Adding FixedWithBuild Feature

-------------------------------------------------------------------------------------------
DISCLAIMER:

This Sample Code is provided for the purpose of illustration only and is not intended to 
be used in a production environment.

THIS SAMPLE CODE AND ANY RELATED INFORMATION ARE PROVIDED AS IS
WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.


We grant You a nonexclusive, royalty-free right to use and modify the Sample Code
and to reproduce and distribute the object code form of the Sample Code, provided
that You agree:
(i)	to not use Our name, logo, or trademarks to market Your software
        product in which the Sample Code is embedded; 
(ii)	to include a valid copyright notice on Your software product in which 
        the Sample Code is embedded; and 
(iii)	to indemnify, hold harmless, and defend Us and Our suppliers from and 
        against any claims or lawsuits, including attorneys' fees, that arise 
        or result from the use or distribution of the Sample Code.

Please note: None of the conditions outlined in the disclaimer above will supersede terms 
             and conditions contained within the Premier Customer Services Description.


ALL CODE MUST BE TESTED BY ANY RECIPIENTS AND SHOULD NOT BE RUN IN A PRODUCTION ENVIRONMENT 
WITHOUT MODIFICATION BY THE RECIPIENT.

CODE CHANGES ARE NOT PERMITTED. EXPLICIT ALLOWANCE MUST BE GRANTED!

=========================================================================================
EXAMPLE: 
powershell.exe -file Update_WinRE_CVE2022-41099.ps1
=========================================================================================#>

#Description: Writes a message including Timestamp and Severity to a log file
#Function Data:
#   Name:           Write-Log
#   Parameters:     LogFile, Classification, Level, Message
#   Returns:        None
Function Write-Log 
{
    <#
        .SYNOPSIS
        Write Log File

        .DESCRIPTION
        Writes a message including Timestamp and Severity to a log file.

        .PARAMETER Classification
        Specifies the Classification of the Message.
        Possible Values: IMPORTANT, INFO, DEBUG

        .PARAMETER Level
        Specifies the Severity of the Message.
        Possible Values: INFO, WARN, ERROR, FATAL, DEBUG, TRACE

        .PARAMETER LogFile
        Specifies the LogFile Path

        .PARAMETER Message
        Specifies the Message

        .EXAMPLE
        Write-Log -Message "Text" -Classification INFO

        .EXAMPLE
        Write-Log -Message "Text" -Classification INFO -LogFile "%Temp%\Logfile.log"
    #>

    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$False)]
        [string]
        $LogFile = $global:LogFilePath,

        [Parameter(Mandatory=$False)]
        [ValidateSet("INFO","WARN","ERROR","FATAL","DEBUG","TRACE")]
        [String]
        $Level = "INFO",

        [Parameter(Mandatory=$True)]
        [string]
        $Message
    )

    #Internal Declarations and Definition Updates
    $Stamp        = (Get-Date).toString("yyyy/MM/dd HH:mm:ss")
    $HeaderString = "Timestamp".PadRight(22, ' ') + "Level".PadRight(10, ' ') + "Message".PadRight(60,' ')
    $LineString   = $Stamp.PadRight(22, ' ') + $Level.PadRight(10, ' ') + $Message.PadRight(60,' ')

    #Verify if Log File already exists
    If(Test-Path $LogFile) 
    {
        #Writing to Log File
        Add-Content -Path $LogFile -Value $LineString
    }
    Else 
    {
        #Writing to Log File including Header Line
        Add-Content -Path $LogFile -Value $HeaderString
        Add-Content -Path $LogFile -Value $LineString
    }

    #Writing to Debug Window
    if($global:DebugMode)
    {
        Write-Host $LineString
    }
}

#Description: Debug output of WinRE details
#Function Data:
#   Name:           Write-WinReDebugOutput 
#   Parameters:     WinRE
#   Returns:        None
Function Write-WinReDebugOutput 
{
    <#
        .SYNOPSIS
        Debug output of WinRE details

        .DESCRIPTION
        Debug output of WinRE details

        .PARAMETER WinRE
        Data to output

        .EXAMPLE
        Write-WinReDebugOutput -WinRE $WinRE_Current
    #>

    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True)]
        $WinRE
    )

    Write-Log -Level INFO -Message "WinRE.WIM File Information"
    Write-Log -Level INFO -Message " -> Path     : $($WinRE.ImagePath)"
    Write-Log -Level INFO -Message " -> Existing : $($WinRE.ImageExisting)"
    Write-Log -Level INFO -Message " -> Status   : $($WinRE.Enabled)"
    Write-Log -Level INFO -Message " -> Version  : $($WinRE.Version)"
    Write-Log -Level INFO -Message " -> Modified : $($WinRE.ModifiedTime)"
}

#Description: Test for exit conditions
#Function Data:
#   Name:           Test-ExitConditions
#   Parameters:     none
#   Returns:        int
#                   0    = ERROR_SUCCESS#                   
#                   1627 = ERROR_PATCH_PACKAGE_UNSUPPORTED
#                   3010 = ERROR_SUCCESS_REBOOT_REQUIRED 
#                   9999 = Already Patched
Function Test-ExitConditions
{
    <#
        .SYNOPSIS
        Test for exit conditions

        .DESCRIPTION
        Test for exit conditions

        .PARAMETER none

        .EXAMPLE
        Test-ExitConditions
    #>

    #Exit Condition for non-64bit Systems
    if (![Environment]::Is64BitOperatingSystem) 
    {
        Write-Log -Level ERROR -Message "<Exit Condition>"
        Write-Log -Level ERROR -Message " -> OS is not 64bit. The procedure is intended for 64 bit OS only."
        return $global:ERROR_PATCH_PACKAGE_UNSUPPORTED
    }

    #Exit Condition for Reboot Required
    if((Test-Path -Path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired') `
        -or (Test-Path -Path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending') )
    {
        Write-Log -Level ERROR -Message "<Exit Condition>"
        Write-Log -Level ERROR -Message " -> Computer has pending reboot or pending update."
        Write-Log -Level ERROR -Message " -> Unable to update WinRE until the computer is rebooted."
        return $global:ERROR_SUCCESS_REBOOT_REQUIRED 
    }    

    #Exit Condition for CVE Mitigation Completed    
    if(Test-Path "$($global:RegCompletionCVEHive + ":\" + $global:RegCompletionCVEPath)")
    {
        $result = Get-ItemProperty -Path "$($global:RegCompletionCVEHive + ":\" + $global:RegCompletionCVEPath)" -Name $global:RegCompletionCVEName -ErrorAction SilentlyContinue
        if($result.'CVE-2022-41099' -eq 1)
        {
            Write-Log -Level ERROR -Message "<Exit Condition>"
            Write-Log -Level ERROR -Message " -> System already updated."
            return $global:ERROR_ALREADY_PATCHED
        }
    }  

    #Exit Success
    return -1
}

#Description: Add an update entry
#Function Data:
#   Name:           Add-UpdatePaths
#   Parameters:     OSVersion
#                   OSDescription
#                   FixedWithBuild
#                   KBCU
#                   URICU
#                   KBSafeOS
#                   URISafeOSUpdate
#   Returns:        Custom PSObject
Function Add-UpdatePaths
{
    <#
        .SYNOPSIS
        Add a update entry

        .DESCRIPTION
        Add a update entry

        .PARAMETER OSVersion
        Build version of Operating System

        .PARAMETER OSDescription
        Description of Operating System

        .PARAMETER FixedWithBuild
        First CU Built # Fixing this CVE

        .PARAMETER KBCU
        KB for cumulative update

        .PARAMETER URICU
        Download path of cumulative update

        .PARAMETER KBSafeOS
        KB for SafeOS update

        .PARAMETER URISafeOS
        Download path of SafeOS update

        .OUTPUTS
        Custom Object with data

        .EXAMPLE
        Add-UpdatePaths -OSVersion 22621 -KBCU "KB5022303" -URICU <...> -KBSafeOS "KB5022609" -URISafeOS <...>
    #>
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True)]
        [Int32]
        $OSVersion,

        [Parameter(Mandatory=$True)]
        [String]
        $OSDescription,

        [Parameter(Mandatory=$True)]
        [Int32]
        $FixedWithBuild,

        [Parameter(Mandatory=$True)]
        [String]
        $KBCU,

        [Parameter(Mandatory=$True)]
        [String]
        $URICU,

        [Parameter(Mandatory=$True)]
        [String]
        $KBSafeOS,

        [Parameter(Mandatory=$True)]
        [String]
        $URISafeOS
    )

    #internal declarations
    $private:update = New-Object PSCustomObject

    #adding the values
    $private:update | Add-Member -type NoteProperty -Name OSVersion -Value ($OSVersion)
    $private:update | Add-Member -type NoteProperty -Name OSDescripiton -Value ($OSDescription)
    $private:update | Add-Member -type NoteProperty -Name FixedWithBuild -Value ($FixedWithBuild)
    $private:update | Add-Member -type NoteProperty -Name KBCU -Value $KBCU
    $private:update | Add-Member -type NoteProperty -Name URICU -Value $URICU
    $private:update | Add-Member -type NoteProperty -Name KBSafeOS -Value $KBSafeOS
    $private:update | Add-Member -type NoteProperty -Name URISafeOS -Value $URISafeOS

    #Return Data
    return $private:update
}

#Description: Get the update entry
#Function Data:
#   Name:           Get-UpdatePath
#   Parameters:     UpdatesAvailable
#                   OSVersion
#   Returns:        Custom PSObject
Function Get-UpdateEntry
{
    <#
        .SYNOPSIS
        Get the update entry

        .DESCRIPTION
        Get the update entry

        .PARAMETER UpdatesAvailable
        All available updates

        .PARAMETER OSVerison
        Operating System to search ofr

        .OUTPUTS
        Custom Object with data

        .EXAMPLE
        Get-UpdateEntry -UpdateAvailable <variable> -OSVersion "10.0.22621"
    #>
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True)]
        $UpdatesAvailable,

        [Parameter(Mandatory=$True)]
        [Int32]
        $OSVersion
    )

    #search for the OSVersion
    foreach($update in $UpdatesAvailable)
    {
        if ($update.OSVersion -eq $OSVersion)
        {
            return $update
        }
    }

    #Return Data
    return New-Object PSCustomObject
}

#Description: Add an update entry
#Function Data:
#   Name:           Add-UpdatePaths
#   Parameters:     OSVersion
#                   OSDescription
#                   KBCU
#                   URICU
#                   KBSafeOS
#                   URISafeOSUpdate
#   Returns:        Custom PSObject
Function Get-WinREData
{
    <#
        .SYNOPSIS
        Get data of WinRE.WIM file

        .DESCRIPTION
        Get data of WinRE.WIM file

        .OUTPUTS
        Custom Object with data

        .EXAMPLE
        Get-WinREData
    #>

    #internal declarations
    $private:winre = New-Object PSCustomObject

    #get WinRE.wim information
    if (-NOT (Test-Path "$env:SystemRoot\System32\Recovery\ReAgent.xml")) {
        Write-Warning "Unable to find $env:SystemRoot\System32\Recovery\ReAgent.xml"
    }
    else 
    {
        [xml]$XmlDocument = Get-content -Path "$env:SystemRoot\System32\Recovery\ReAgent.xml" -Raw
        $XmlDocument.SelectNodes('WindowsRE') | ForEach-Object {
            $local:WinRE_LocationId = $_.WinreLocation.id
            $local:WinRE_LocationOffset = $_.WinreLocation.offset
            $local:WinRE_LocationPath = $_.WinreLocation.path
            $local:WinRE_LocationPartition = (Get-Disk -Number $local:WinRE_LocationId | Get-Partition | Where-Object {$_.Offset -eq $local:WinRE_LocationOffset}).PartitionNumber
            $WinRE_InstallState = $_.InstallState.state
            $WinRE_Enabled = if ($WinRE_InstallState -eq 0) { $false } else { $true }
            $WinRE_IsAutoRepairOn = $_.IsAutoRepairOn.state
            $WinRE_OsBuildVersion = $_.OsBuildVersion.path
            $WinRE_Location = '\\?\GLOBALROOT\device\harddisk' + $local:WinRE_LocationId + '\partition' + $local:WinRE_LocationPartition + $local:WinRE_LocationPath
        }

        #adding the values
        $local:WinREData = (Get-WindowsImage -imagepath (($WinRE_Location).TRIM() + "\winre.wim") -index 1)
        $private:winre | Add-Member -type NoteProperty -Name Enabled -Value $WinRE_Enabled
        $private:winre | Add-Member -type NoteProperty -Name Build -Value $local:WinREData.SPBuild
        $private:winre | Add-Member -type NoteProperty -Name AutoRepairOn -Value $WinRE_IsAutoRepairOn
        $private:winre | Add-Member -type NoteProperty -Name Version -Value $local:WinREData.Version
        $private:winre | Add-Member -type NoteProperty -Name ModifiedTime -Value $local:WinREData.ModifiedTime
        $private:winre | Add-Member -type NoteProperty -Name CreatedTime -Value $local:WinREData.CreatedTime
        $private:winre | Add-Member -type NoteProperty -Name OsBuildVersion -Value $WinRE_OsBuildVersion
        $private:winre | Add-Member -type NoteProperty -Name ImagePath -Value $local:WinREData.ImagePath
        $private:winre | Add-Member -type NoteProperty -Name ImageName -Value $local:WinREData.ImageName
        $private:winre | Add-Member -type NoteProperty -Name ImageExisting -Value ([System.IO.File]::Exists($local:WinREData.ImagePath))
    }

    #Return Data
    return $private:winre
}

#Description: Download the required update
#Function Data:
#   Name:           Invoke-DownloadUpdate
#   Parameters:     UpdatePackage
#                   LocalUpdateFile
#   Returns:        Boolean
#                   True  = Success
#                   False = Failure
Function Invoke-DownloadUpdate
{
    <#
        .SYNOPSIS
        Download the required update

        .DESCRIPTION
        Download the required update

        .PARAMETER UpdatePackage
        Update package details

        .PARAMETER LocalUpdateFile
        Local update file

        .EXAMPLE
        Invoke-DownloadUpdate -UpdatePackage $Update
    #>

    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True)]
        $UpdatePackage,

        [Parameter(Mandatory=$True)]
        [string]
        $LocalUpdateFile
    )

    #Internal declaration
    $OfflinePackageFound = $false
    $OfflineFileName = [String]::Empty

    #Set the action preference
    $ProgressPreference = 'SilentlyContinue'  
    try 
    {
        #Try offline mode if available
        if($global:PriorizedOfflineMode)
        {
            if($global:DeploymentModeSafeOS)
            {
                #Using Offline SafeOS Package
                Write-Log -Level INFO -Message " -> Searching for Offline SafeOS Update <$($UpdatePackage.KBSafeOS)> in path <$($global:PriorizedOfflinePath)>"
                $OfflineFileName = (Get-ChildItem -Path $global:PriorizedOfflinePath | Where-Object Name -like "*$($UpdatePackage.KBSafeOS)*").FullName
            }
            else 
            {
                #Using Offline CU Package
                Write-Log -Level INFO -Message " -> Searching for Offline Cumulative Update Update <$($UpdatePackage.KBCU)> in path <$($global:PriorizedOfflinePath)>"
                $OfflineFileName = (Get-ChildItem -Path $global:PriorizedOfflinePath | Where-Object Name -like "*$($UpdatePackage.KBCU)*").FullName
            }

            if($null -ne $OfflineFileName)
            {
                #File Found Info
                Write-Log -Level INFO -Message "    -> Update package detected <$($OfflineFileName)>"
                Write-Log -Level INFO -Message "    -> Staging package <$($global:DownloadFile)>"

                #Copy the item to local storage
                Copy-Item -Path $OfflineFileName -Destination $global:DownloadFile -Force -ErrorAction Stop
                Write-Log -Level INFO -Message "    -> Copy process to temporary local file succeeded."

                #Set variable for Offline File 
                $OfflinePackageFound = $true
            }
            else 
            {
                #File Not Found
                Write-Log -Level FATAL -Message "    -> Update package not found"
            }
        }

        if(($PriorizedOfflineMode -and $OfflinePackageFound -eq $False) -or !$PriorizedOfflineMode)
        {
            #Download the required update package
            if($global:DeploymentModeSafeOS)
            {
                #Downloading SafeOS Package
                Write-Log -Level INFO -Message " -> Downloading SafeOS Update <$($UpdatePackage.KBSafeOS)>"
                $WebRequestResult = Invoke-WebRequest -Uri $UpdatePackage.URISafeOS -OutFile $DownloadFile -UseBasicParsing -PassThru
            }
            else
            {
                #Downloading Cumulate Update Package
                Write-Log -Level INFO -Message " -> Downloading Cumulative Update <$($UpdatePackage.KBCU)>"
                $WebRequestResult = Invoke-WebRequest -Uri $UpdatePackage.URICU -OutFile $DownloadFile -UseBasicParsing -PassThru   
            }
            if($WebRequestResult.StatusCode -eq 200 )
            {
                Write-Log -Level INFO -Message "    -> Downloaded update package successfully <$($DownloadFile)>"
            } 
            else 
            {
                throw "Failed to download update package (Status $($WebRequestResult.StatusCode))"
            }
        }
    }
    catch [System.Net.WebException], [System.IO.IOException] 
    {
        #Exit Failure
        Write-Log -Level FATAL -Message " -> Web / IO Exception: $($_)"    
        return [boolean]$false
    }
    catch 
    {
        #Exit Failure
        Write-Log -Level FATAL -Message " -> Generic ERROR: $($_)"
        return [boolean]$false
    }

    #Exit Success
    return [boolean]$true
}

#Description: Mount the WinRE offline image
#Function Data:
#   Name:           Invoke-MountWinRE
#   Parameters:     WinREPath
#                   MountDir
#                   UpdateFile
#                   UpdatePackage
#   Returns:        Boolean
#                   True  = Success
#                   False = Failure
Function Invoke-UpdateWinRE
{
    <#
        .SYNOPSIS
        Mount the WinRE offline image

        .DESCRIPTION
        Mount the WinRE offline image

        .PARAMETER WinREPath
        WinRE settings

        .PARAMETER MountDir
        MountPoint for offline image

        .PARAMETER UpdateFile
        Path to the update file

        .PARAMETER UpdatePackage
        Update package details

        .EXAMPLE
        Invoke-MountWinRE WinREPath <path to WinRE.WIM>
    #>

    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True)]
        [string]
        $WinREPath,

        [Parameter(Mandatory=$True)]
        [string]
        $MountDir,

        [Parameter(Mandatory=$True)]
        [string]
        $UpdateFile,

        [Parameter(Mandatory=$True)]
        $UpdatePackage
    )

    #Set the action preference
    $ProgressPreference = 'SilentlyContinue'        

    try 
    {
        #Check if the local mount point exists
        if (!(Test-Path -PathType Container -Path $MountDir)) 
        { 
            #Create new directory if not existing
            Write-Log -Level INFO -Message " -> Creating mount point <$($MountDir)>"
            New-Item -ItemType Directory -Path $MountDir -Force | Out-Null
        }

        #Mount the WinRE offline image
        if( ( Invoke-Process -Path ReAgentC.exe -Arguments "/mountre /path $($MountDir)" ) -eq 0)
        {
            Write-Log -Level INFO -Message "    -> Mounting Windows RE successful"
        } 
        else 
        {
            throw "    -> Mounting Windows RE Image Failed. Output: $REMountResult"
        }

        #Validate the Update Status
        $KB = ""
        if ($global:DeploymentModeSafeOS)
        {
            $KB = $UpdatePackage.KBSafeOS
        }
        else 
        {
            $KB = $UpdatePackage.KBCU    
        }
        $UpdateStatus = Get-WindowsPackage -Path $MountDir | Where-Object -Property PackageName -like "*$($KB)*" | Where-Object -Property PackageState -eq "Installed"
        Write-Log -Level INFO -Message " -> Installed packages for <$($KB)> found: $($UpdateStatus.Count)"
		if($UpdateStatus.Count -eq 0)
        {
            #Add the update package
            Write-Log -Level INFO -Message " -> Running DISM Add-Package"
            try 
            {
                Add-WindowsPackage -Path "$($MountDir)" -PackagePath "$($UpdateFile)" -NoRestart
                Write-Log -Level INFO -Message "    -> DISM Add-Package Successful"
            }
            catch
            {
                Write-Log -Level INFO -Message "    -> DISM Add-Package Failed."
            }

            #Run Cleanup-Image command
            Write-Log -Level INFO -Message " -> Running DISM Cleanup-Image" 
            Write-Log -Level INFO -Message "    -> Sleeping 5s to prevent DISM Error 0x800f0823" #https://www.reddit.com/r/sysadmin/comments/10a1enh/how_are_you_updating_winre_to_address_cve202241099/j480gos/
            Start-Sleep -Seconds 5
            if( ( Invoke-Process -Path "Dism.exe" -Arguments "/image:$($MountDir) /cleanup-image /StartComponentCleanup /ResetBase" ) -eq 0)
            {
                Write-Log -Level INFO -Message "    -> DISM Cleanup-Image Successful"
            }
            else 
            {
                throw "    -> DISM Cleanup-Image Failed"
            }  

            #Unmount the WinRE offline image
            Write-Log -Level INFO -Message " -> Dismounting and Saving Windows RE" 
            Write-Log -Level INFO -Message "    -> Sleeping 5s to prevent DISM Error 0x800f0823" #https://www.reddit.com/r/sysadmin/comments/10a1enh/how_are_you_updating_winre_to_address_cve202241099/j480gos/
            Start-Sleep -Seconds 5
            Write-Log -Level INFO -Message "    -> Dismounting Windows RE image"
            Dismount-WindowsImage -Path $MountDir -Save -CheckIntegrity
        }  
        else 
        {
            Write-Log -Level INFO -Message "    -> Update not required"  
            
            #Unmount the WinRE offline image
            Write-Log -Level INFO -Message " -> Dismounting and Discarding Windows RE"
            Dismount-WindowsImage -Path $MountDir -Discard
        }
    }    
    catch 
    {
        #Exit Failure
        Write-Log -Level FATAL -Message "    -> Generic ERROR: $($_)"
        return [boolean]$false
    }

    #Exit Success
    return [boolean]$true
}

#Description: Invoke running a process
#Function Data:
#   Name:           Invoke-Process
#   Parameters:     Path, Parameter
#   Returns:        Exit Code
Function Invoke-Process
{
    <#
        .SYNOPSIS
        Invoke running a process

        .DESCRIPTION
        Invoke running a process

        .PARAMETER Path
        Name of the Process

        .PARAMETER Arguments
        Arguments for the call

        .EXAMPLE
        Invoke-Process -Path <name of process> -Arguments <parameters>
    #>

    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True)]
        [string]
        $Path,

        [Parameter(Mandatory=$True)]
        [string]
        $Arguments
    )

    #Set the action preference
    $ProgressPreference = 'SilentlyContinue'  

    #Internal declarations
    $pinfo = New-Object System.Diagnostics.ProcessStartInfo
    $p = New-Object System.Diagnostics.Process

    #Process Parameters
    $pinfo.FileName = $Path
    $pinfo.RedirectStandardError = $True
    $pinfo.RedirectStandardInput = $True
    $pinfo.RedirectStandardOutput = $True
    $pinfo.LoadUserProfile        = $False
    $pinfo.UseShellExecute = $false
    $pinfo.WindowStyle = 'Hidden'
    $pinfo.Arguments = $Arguments    
    $p.StartInfo = $pinfo

    #Start and Wait for Process
    $p.Start() | Out-Null    
    $p.WaitForExit()

    #Return the ExitCode
    return $p.ExitCode
}

#Description: Update the TPM hash for WinRE image
#Function Data:
#   Name:           Invoke-TPMHashUpdate
#   Parameters:     none
#   Returns:        Boolean
#                   True  = Success
#                   False = Failure
Function Invoke-TPMHashUpdate
{
    <#
        .SYNOPSIS
        Update the TPM hash for WinRE image

        .DESCRIPTION
        Update the TPM hash for WinRE image

        .PARAMETER WinRE
        WinRE Details

        .EXAMPLE
        Invoke-TPMHashUpdate
    #>

    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True)]
        $WinRE
    )

    #Set the action preference
    $ProgressPreference = 'SilentlyContinue'  

    #Local Declarations
    $Tasks = @(
        [PSCustomObject]@{Name = 'Disable';  CommandParam = '/disable'}
        [PSCustomObject]@{Name = 'Enable';   CommandParam = '/enable'}
    )   

    #Update the WinRE hash in TPM
    Write-Log -Level INFO -Message "Updating the TPM Hash for WinRE"
    if($WinRE.Enabled -eq $true)
    {
        try 
        {
            #Update the WinRE hash in TPM             
            foreach($Task in $Tasks)
            {
                Write-Log -Level INFO -Message " -> $($Task.Name) WinRE"
                
                if((Invoke-Process -Path "reagentc.exe" -Arguments $Task.CommandParam) -eq 0)
                {
                    Write-Log -Level INFO -Message "     -> Success"
                }
                else 
                {
                    Write-Log -Level INFO -Message "     -> Failed (ExitCode=$($ProcessDetails.ExitCode))"    
                }
            }
        }
        catch 
        {
            #Exit Failure
            Write-Log -Level FATAL -Message " -> Generic ERROR: $($_)"
            return [boolean]$false
        }
    }
    else 
    {
        Write-Log -Level INFO -Message " -> WinRE not enabled. Update not required."
    }

    #Exit Success
    return [boolean]$true
}

##################################################################################################################
####                                    P R O G R A M    P A R A M E T E R S                                  ####
##################################################################################################################

#Debug Mode
$global:DebugMode               = [Boolean]$true

#DeploymentMode
$global:DeploymentModeSafeOS    = [Boolean]$true            #$true = SafeOS update, $false = full cumulative update

#OfflineMode
$global:PriorizedOfflineMode    = [Boolean]$true            #$true = offline SafeOS update - if not available CDN Download, $false = download from CDN depending on DeploymentModeSafeOS value
$global:PriorizedOfflinePath    = $PSScriptRoot             #Path of the offline files  

#Log File
$global:LogFilePath             = [System.Environment]::ExpandEnvironmentVariables("%TEMP%\Update-WinRE-CVE-2022-41099.log")

#Temporary Data
$MountDir                       = [System.Environment]::ExpandEnvironmentVariables("%SYSTEMDRIVE%\MOUNT")
$DownloadFile                   = [System.Environment]::ExpandEnvironmentVariables("%TEMP%\Update_WinRE.cab")

#Registry Values
$global:RegCompletionCVEHive    = "HKLM"
$global:RegCompletionCVEPath    = "SOFTWARE\Microsoft\CVE"
$global:RegCompletionCVEName    = "CVE-2022-41099"

#Available Updates for CVE-2022-41099
$global:Updates = @()
$global:Updates += Add-UpdatePaths -OSVersion 22621 -OSDescription "Windows 11 22H2 - Build 22621" -FixedWithBuild 1105 -KBCU "KB5022303" -URICU "https://catalog.s.download.windowsupdate.com/d/msdownload/update/software/crup/2023/01/windows11.0-kb5022609-x64_1f5e0fd80fdd08e541903b0d2d845d5b88bee2b4.cab" -KBSafeOS "KB5022609" -URISafeOS "https://catalog.s.download.windowsupdate.com/d/msdownload/update/software/crup/2023/01/windows11.0-kb5022609-x64_1f5e0fd80fdd08e541903b0d2d845d5b88bee2b4.cab"
$global:Updates += Add-UpdatePaths -OSVersion 22000 -OSDescription "Windows 11 21H2 - Build 22000" -FixedWithBuild 1455 -KBCU "KB5022287" -URICU "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021040-x64_2216fe185502d04d7a420a115a53613db35c0af9.cab" -KBSafeOS "KB5021040" -URISafeOS "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021040-x64_2216fe185502d04d7a420a115a53613db35c0af9.cab"
$global:Updates += Add-UpdatePaths -OSVersion 19045 -OSDescription "Windows 10 22H2 - Build 19045" -FixedWithBuild 2486 -KBCU "KB5022282" -URICU "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021043-x64_efa19d2d431c5e782a59daaf2d04d026bb8c8e76.cab" -KBSafeOS "KB5021043" -URISafeOS "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021043-x64_efa19d2d431c5e782a59daaf2d04d026bb8c8e76.cab"
$global:Updates += Add-UpdatePaths -OSVersion 19044 -OSDescription "Windows 10 21H2 - Build 19044" -FixedWithBuild 2486 -KBCU "KB5022282" -URICU "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021043-x64_efa19d2d431c5e782a59daaf2d04d026bb8c8e76.cab" -KBSafeOS "KB5021043" -URISafeOS "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021043-x64_efa19d2d431c5e782a59daaf2d04d026bb8c8e76.cab"
$global:Updates += Add-UpdatePaths -OSVersion 19043 -OSDescription "Windows 10 21H1 - Build 19043" -FixedWithBuild 2364 -KBCU "KB5021233" -URICU "https://catalog.s.download.windowsupdate.com/d/msdownload/update/software/secu/2022/12/windows10.0-kb5021233-x64_4b20e15fe6e4cf264be4651f95395e8980684a17.cab" -KBSafeOS "KB5021043" -URISafeOS "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021043-x64_efa19d2d431c5e782a59daaf2d04d026bb8c8e76.cab"
$global:Updates += Add-UpdatePaths -OSVersion 19042 -OSDescription "Windows 10 20H2 - Build 19042" -FixedWithBuild 2486 -KBCU "KB5022282" -URICU "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021043-x64_efa19d2d431c5e782a59daaf2d04d026bb8c8e76.cab" -KBSafeOS "KB5021043" -URISafeOS "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021043-x64_efa19d2d431c5e782a59daaf2d04d026bb8c8e76.cab"
$global:Updates += Add-UpdatePaths -OSVersion 17763 -OSDescription "Windows 10 1809 - Build 17763" -FixedWithBuild 3887 -KBCU "KB5022286" -URICU "https://catalog.s.download.windowsupdate.com/d/msdownload/update/software/secu/2023/01/windows10.0-kb5022286-x64_6e84985d215be67ce1395cb2627b5ee68cf4dcb6.msu" -KBSafeOS "KB5021042" -URISafeOS "https://catalog.s.download.windowsupdate.com/d/msdownload/update/software/crup/2022/11/windows10.0-kb5021042-x64_19bb9778b2098cc038a03d3c40f4a16bd80e69d3.cab"
$global:Updates += Add-UpdatePaths -OSVersion 14393 -OSDescription "Windows 10 1607 - Build 14393" -FixedWithBuild 5648 -KBCU "KB5022289" -URICU "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/secu/2023/01/windows10.0-kb5022289-x64_79d8b59c2bea46d286f2960920c075f416446445.msu" -KBSafeOS "KB5021039" -URISafeOS "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021039-x64_c6da7558fda35928213772e4e552f2360076e683.cab"

#Error and Exit Codes
$global:ERROR_SUCCESS                               = 0
$global:ERROR_ALREADY_PATCHED                       = 1
$global:ERROR_UNKNOWN                               = 1000
$global:ERROR_PREREQ_FAILURE                        = 1599
$global:ERROR_PATCH_PACKAGE_UNSUPPORTED             = 1627
$global:ERROR_PATCH_NO_SEQUENCE                     = 1648
$global:ERROR_DOWNLOAD_FAILURE                      = 1680
$global:ERROR_PATCH_UPDATE_FAILED                   = 1688
$global:ERROR_TPM_UPDATE_FAILED                     = 1689
$global:ERROR_SUCCESS_REBOOT_REQUIRED               = 3010
$Rewrite_ERROR_ALREADY_PATCHED_to_ERROR_SUCCESS     = $true

#Setting Security Protocol for .Net Framework to use TLS1.2...
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12


##################################################################################################################
####                                 P R O G R A M    S E Q U E N C E   C O D E                               ####
##################################################################################################################

#Program Start
$Starttime = Get-Date
$ExitCode  = $global:ERROR_SUCCESS

#Debug Output of Program Start
Write-Log -Level INFO -Message "##################################################################################################################"
Write-Log -Level INFO -Message "####                            P R O G R A M    S E Q U E N C E   S T A R T                                  ####"
Write-Log -Level INFO -Message "##################################################################################################################"
Write-Log -Level INFO -Message "Configuration Parameters"
Write-Log -Level INFO -Message " -> Debug Mode                : $($global:DebugMode)"
Write-Log -Level INFO -Message " -> Priorized Offline Mode    : $($global:PriorizedOfflineMode)"
Write-Log -Level INFO -Message " -> Priorized Offline Path    : $($global:PriorizedOfflinePath)"
Write-Log -Level INFO -Message " -> Deployment SafeOS Package : $($global:DeploymentModeSafeOS)"

#Get Details of WinRE.WIM file
$WinRE_Current = Get-WinREData
Write-WinReDebugOutput -WinRE $WinRE_Current

#Check for Exit Conditions
$tmpReturnCodeExitConditions = Test-ExitConditions
if ($tmpReturnCodeExitConditions -eq -1)
{
    #Debug Output
    Write-Log -Level INFO -Message "<Exit Condition> tests successfully completed..."

    #Get Details of OS
    $OSVersion = (Get-CimInstance Win32_OperatingSystem).Version
    $OSBuildNumber = (Get-CimInstance Win32_OperatingSystem).BuildNumber
    Write-Log -Level INFO -Message "Current Operating System"
    Write-Log -Level INFO -Message " -> Version  : $($OSVersion)"

    #Internal Error Handling
    #If image path found, then try to patch
    if( ($WinRE_Current.ImagePath.Length -gt 0) -and ($WinRE_Current.ImageExisting))
    {
        try 
        {
            #Get the required update package
            $UpdatePackage = Get-UpdateEntry -UpdatesAvailable $global:Updates -OSVersion $OSBuildNumber

            #Check for fixed version
            if ( $UpdatePackage.FixedWithBuild -le $WinRE_Current.Build )
            {
                Write-Log -Level FATAL -Message "WinRE Build version fixed"
                Write-Log -Level FATAL -Message " -> WinRE Version: $($WinRE_Current.Build)"
                Write-Log -Level FATAL -Message " -> Fixed Version: $($UpdatePackage.FixedWithBuild)"
                $ExitCode = $ERROR_ALREADY_PATCHED; 
                throw "WinRE already updated"                
            }

            #Download the required update package
            Write-Log -Level INFO -Message "Download the update package"
            if($UpdatePackage.length -ne 0)
            {
                if(!(Invoke-DownloadUpdate -UpdatePackage $UpdatePackage -LocalUpdateFile $DownloadFile))
                {
                    #Error Handling
                    $ExitCode = $global:ERROR_DOWNLOAD_FAILURE
                    throw "Aborting WinRE update process"
                }            
            }
            else 
            {
                #Error Handling
                $ExitCode = $global:ERROR_PATCH_NO_SEQUENCE   
                throw "No update available for this system"
            }

            #Update the WinRE.WIM offline image
            Write-Log -Level INFO -Message "Update the local WinRE offline image"
            if(!(Invoke-UpdateWinRE -WinREPath $WinRE_Current.ImagePath -MountDir $MountDir -UpdateFile $DownloadFile -UpdatePackage $UpdatePackage ))
            {
                #Error Handling
                $ExitCode = $global:ERROR_PATCH_UPDATE_FAILED
                throw "Aborting WinRE update process"
            }

            #Update the WinRE.WIM hash in TPM
            if(!(Invoke-TPMHashUpdate -WinRE $WinRE_Current))
            {
                #Error Handling
                $ExitCode = $global:ERROR_TPM_UPDATE_FAILED
                throw "Aborting WinRE update process"
            }            
        }    
        catch 
        {
            Write-Log -Level FATAL -Message " -> ERROR: $($_)"    
            if($ExitCode -eq 0) 
            { 
                $ExitCode = $global:ERROR_UNKNOWN 
            }           

            if (Test-Path -PathType Container -Path ($MountDir + "\Windows")) 
            { 
                Write-Log -Level INFO -Message "Dismounting Windows RE due to it is still mounted. Discarding changes."
                Dismount-WindowsImage -Path $MountDir -Discard
            }
        }    

        #Get Details of WinRE.WIM file
        $WinRE_Updated = Get-WinREData
        Write-WinReDebugOutput -WinRE $WinRE_Updated

        #Clean-up tasks
        Write-Log -Level INFO -Message "Cleaning up files and directories"
        if (Test-Path -PathType Container -Path $MountDir) 
        { 
            Write-Log -Level INFO -Message " -> Removing directory <$($MountDir)>"
            Remove-Item -Path $MountDir -Force 
        }
        if (Test-Path -Path $DownloadFile) 
        { 
            Write-Log -Level INFO -Message " -> Removing downloaded file <$($DownloadFile)>"
            Remove-Item -Path $DownloadFile -Force -Recurse
        }

        #Write Patching Result to Registry
        if ($ExitCode -eq $ERROR_SUCCESS -or $ExitCode -eq $ERROR_ALREADY_PATCHED)
        {
            Write-Log -Level INFO -Message "Creating completion event in the System Registry"
            $tmpRegistryPath = $global:RegCompletionCVEHive + ":\" + $global:RegCompletionCVEPath
            If ( !(Test-Path $tmpRegistryPath) ) { New-Item -Path $tmpRegistryPath -Force -ErrorAction SilentlyContinue | Out-Null }
            New-ItemProperty -Path $tmpRegistryPath -Name $global:RegCompletionCVEName -Value 1 -ErrorAction SilentlyContinue -PropertyType DWord -Force | Out-Null
            Write-Log -Level INFO -Message " -> Successfully created"
        }
    }
    else 
    {
        Write-Log -Level INFO -Message "Windows Recovery Environment not found. No actions required."
    }
}
else
{
    #0    = ERROR_SUCCESS#                   
    #1627 = ERROR_PATCH_PACKAGE_UNSUPPORTED
    #3010 = ERROR_SUCCESS_REBOOT_REQUIRED 
    #9999 = Already Patched
    if ($tmpReturnCodeExitConditions -eq 1627) { Write-Log -Level FATAL -Message "    ERROR_PATCH_PACKAGE_UNSUPPORTED";    $ExitCode = $global:ERROR_PATCH_PACKAGE_UNSUPPORTED; }
    if ($tmpReturnCodeExitConditions -eq 3010) { Write-Log -Level FATAL -Message "    ERROR_SUCCESS_REBOOT_REQUIRED";      $ExitCode = $global:ERROR_SUCCESS_REBOOT_REQUIRED; }
    if ($tmpReturnCodeExitConditions -eq 9999) { Write-Log -Level FATAL -Message "    ERROR_ALREADY_PATCHED";              $ExitCode = $global:ERROR_ALREADY_PATCHED; }
    if ($ExitCode -eq -1)                      { Write-Log -Level FATAL -Message "    ERROR_PREREQ_FAILURE";               $ExitCode = $global:ERROR_PREREQ_FAILURE; }
    if ($ExitCode -eq -2)                      { Write-Log -Level FATAL -Message "    ERROR_ALREADY_PATCHED";              $ExitCode = $global:ERROR_ALREADY_PATCHED; }
}


##################################################################################################################
####                                           P R O G R A M   E N D                                           ###
##################################################################################################################

#Program End
$Endtime = Get-Date
$Duration = $Endtime - $Starttime
Write-Log -Level INFO -Message "Program Sequene End [Duration: $Duration]" 


##################################################################################################################
####                                           E X I T  C O D E S                                              ###
##################################################################################################################
<#
    0    = ERROR_SUCCESS
    1    = ERROR_UNKNOWN
    1599 = ERROR_PREREQ_FAILURE
    1627 = ERROR_PATCH_PACKAGE_UNSUPPORTED
    1648 = ERROR_PATCH_NO_SEQUENCE
    1680 = ERROR_DOWNLOAD_FAILURE
    1688 = ERROR_PATCH_UPDATE_FAILED
    1689 = ERROR_TPM_UPDATE_FAILED
    3010 = ERROR_SUCCESS_REBOOT_REQUIRED
    9999 = ERROR_ALREADY_PATCHED
#>

if($Rewrite_ERROR_ALREADY_PATCHED_to_ERROR_SUCCESS) {$ExitCode = $ERROR_SUCCESS}
Write-Log -Level INFO -Message " -> Exit code: $ExitCode"
exit $ExitCode
