<#=========================================================================================
Files:     Update_WinRE_CVE-2022-41099.ps1

Summary:
This script is used to check the local WinRE for a vulnerability to CVE-2022-41099.


Version	    Date		Author				Description
-------------------------------------------------------------------------------------------
    1.0     2023-03-31  Juergen Kutschera	Script created

-------------------------------------------------------------------------------------------
DISCLAIMER:

This Sample Code is provided for the purpose of illustration only and is not intended to 
be used in a production environment.

THIS SAMPLE CODE AND ANY RELATED INFORMATION ARE PROVIDED AS IS
WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.


We grant You a nonexclusive, royalty-free right to use and modify the Sample Code
and to reproduce and distribute the object code form of the Sample Code, provided
that You agree:
(i)	to not use Our name, logo, or trademarks to market Your software
        product in which the Sample Code is embedded; 
(ii)	to include a valid copyright notice on Your software product in which 
        the Sample Code is embedded; and 
(iii)	to indemnify, hold harmless, and defend Us and Our suppliers from and 
        against any claims or lawsuits, including attorneys' fees, that arise 
        or result from the use or distribution of the Sample Code.

Please note: None of the conditions outlined in the disclaimer above will supersede terms 
             and conditions contained within the Premier Customer Services Description.


ALL CODE MUST BE TESTED BY ANY RECIPIENTS AND SHOULD NOT BE RUN IN A PRODUCTION ENVIRONMENT 
WITHOUT MODIFICATION BY THE RECIPIENT.

CODE CHANGES ARE NOT PERMITTED. EXPLICIT ALLOWANCE MUST BE GRANTED!

=========================================================================================
EXAMPLE: 
powershell.exe -file Test-WinRE-CVE2022-41099.ps1
=========================================================================================#>

#Description: Writes a message including Timestamp and Severity to a log file
#Function Data:
#   Name:           Write-Log
#   Parameters:     LogFile, Classification, Level, Message
#   Returns:        None
Function Write-Log 
{
    <#
        .SYNOPSIS
        Write Log File

        .DESCRIPTION
        Writes a message including Timestamp and Severity to a log file.

        .PARAMETER Classification
        Specifies the Classification of the Message.
        Possible Values: IMPORTANT, INFO, DEBUG

        .PARAMETER Level
        Specifies the Severity of the Message.
        Possible Values: INFO, WARN, ERROR, FATAL, DEBUG, TRACE

        .PARAMETER LogFile
        Specifies the LogFile Path

        .PARAMETER Message
        Specifies the Message

        .EXAMPLE
        Write-Log -Message "Text" -Classification INFO

        .EXAMPLE
        Write-Log -Message "Text" -Classification INFO -LogFile "%Temp%\Logfile.log"
    #>

    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$False)]
        [string]
        $LogFile = $global:LogFilePath,

        [Parameter(Mandatory=$False)]
        [ValidateSet("INFO","WARN","ERROR","FATAL","DEBUG","TRACE")]
        [String]
        $Level = "INFO",

        [Parameter(Mandatory=$True)]
        [string]
        $Message
    )

    #Internal Declarations and Definition Updates
    $Stamp        = (Get-Date).toString("yyyy/MM/dd HH:mm:ss")
    $HeaderString = "Timestamp".PadRight(22, ' ') + "Level".PadRight(10, ' ') + "Message".PadRight(60,' ')
    $LineString   = $Stamp.PadRight(22, ' ') + $Level.PadRight(10, ' ') + $Message.PadRight(60,' ')

    #Verify if Log File already exists
    If(Test-Path $LogFile) 
    {
        #Writing to Log File
        Add-Content -Path $LogFile -Value $LineString
    }
    Else 
    {
        #Writing to Log File including Header Line
        Add-Content -Path $LogFile -Value $HeaderString
        Add-Content -Path $LogFile -Value $LineString
    }

    #Writing to Debug Window
    if($global:DebugMode)
    {
        Write-Host $LineString
    }
}

#Description: Debug output of WinRE details
#Function Data:
#   Name:           Write-WinReDebugOutput 
#   Parameters:     WinRE
#   Returns:        None
Function Write-WinReDebugOutput 
{
    <#
        .SYNOPSIS
        Debug output of WinRE details

        .DESCRIPTION
        Debug output of WinRE details

        .PARAMETER WinRE
        Data to output

        .EXAMPLE
        Write-WinReDebugOutput -WinRE $WinRE_Current
    #>

    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True)]
        $WinRE
    )

    Write-Log -Level INFO -Message "WinRE.WIM File Information"
    Write-Log -Level INFO -Message " -> Path     : $($WinRE.ImagePath)"
    Write-Log -Level INFO -Message " -> Existing : $($WinRE.ImageExisting)"
    Write-Log -Level INFO -Message " -> Status   : $($WinRE.Enabled)"
    Write-Log -Level INFO -Message " -> Version  : $($WinRE.Version)"
    Write-Log -Level INFO -Message " -> Modified : $($WinRE.ModifiedTime)"
}

#Description: Test for exit conditions
#Function Data:
#   Name:           Test-ExitConditions
#   Parameters:     none
#   Returns:        int
#                   -1   = ERROR_SUCCESS#                   
#                   9999 = ERROR_ALREADY_PATCHED
Function Test-ExitConditions
{
    <#
        .SYNOPSIS
        Test for exit conditions

        .DESCRIPTION
        Test for exit conditions

        .PARAMETER none

        .EXAMPLE
        Test-ExitConditions
    #>

    #Exit Condition for CVE Mitigation Completed    
    if(Test-Path "$($global:RegCompletionCVEHive + ":\" + $global:RegCompletionCVEPath)")
    {
        $result = Get-ItemProperty -Path "$($global:RegCompletionCVEHive + ":\" + $global:RegCompletionCVEPath)" -Name $global:RegCompletionCVEName -ErrorAction SilentlyContinue
        if($result.'CVE-2022-41099' -eq 1)
        {
            Write-Log -Level ERROR -Message "<Exit Condition>"
            Write-Log -Level ERROR -Message " -> System already updated."
            return $global:ERROR_ALREADY_PATCHED
        }
    }  

    #Exit Success
    return -1
}

#Description: Add an update entry
#Function Data:
#   Name:           Add-UpdatePaths
#   Parameters:     OSVersion
#                   OSDescription
#                   FixedWithBuild
#                   KBCU
#                   URICU
#                   KBSafeOS
#                   URISafeOSUpdate
#   Returns:        Custom PSObject
Function Add-UpdatePaths
{
    <#
        .SYNOPSIS
        Add a update entry

        .DESCRIPTION
        Add a update entry

        .PARAMETER OSVersion
        Build version of Operating System

        .PARAMETER OSDescription
        Description of Operating System

        .PARAMETER FixedWithBuild
        First CU Built # Fixing this CVE

        .PARAMETER KBCU
        KB for cumulative update

        .PARAMETER URICU
        Download path of cumulative update

        .PARAMETER KBSafeOS
        KB for SafeOS update

        .PARAMETER URISafeOS
        Download path of SafeOS update

        .OUTPUTS
        Custom Object with data

        .EXAMPLE
        Add-UpdatePaths -OSVersion 22621 -KBCU "KB5022303" -URICU <...> -KBSafeOS "KB5022609" -URISafeOS <...>
    #>
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True)]
        [Int32]
        $OSVersion,

        [Parameter(Mandatory=$True)]
        [String]
        $OSDescription,

        [Parameter(Mandatory=$True)]
        [Int32]
        $FixedWithBuild,

        [Parameter(Mandatory=$True)]
        [String]
        $KBCU,

        [Parameter(Mandatory=$True)]
        [String]
        $URICU,

        [Parameter(Mandatory=$True)]
        [String]
        $KBSafeOS,

        [Parameter(Mandatory=$True)]
        [String]
        $URISafeOS
    )

    #internal declarations
    $private:update = New-Object PSCustomObject

    #adding the values
    $private:update | Add-Member -type NoteProperty -Name OSVersion -Value ($OSVersion)
    $private:update | Add-Member -type NoteProperty -Name OSDescripiton -Value ($OSDescription)
    $private:update | Add-Member -type NoteProperty -Name FixedWithBuild -Value ($FixedWithBuild)
    $private:update | Add-Member -type NoteProperty -Name KBCU -Value $KBCU
    $private:update | Add-Member -type NoteProperty -Name URICU -Value $URICU
    $private:update | Add-Member -type NoteProperty -Name KBSafeOS -Value $KBSafeOS
    $private:update | Add-Member -type NoteProperty -Name URISafeOS -Value $URISafeOS

    #Return Data
    return $private:update
}

#Description: Get the update entry
#Function Data:
#   Name:           Get-UpdatePath
#   Parameters:     UpdatesAvailable
#                   OSVersion
#   Returns:        Custom PSObject
Function Get-UpdateEntry
{
    <#
        .SYNOPSIS
        Get the update entry

        .DESCRIPTION
        Get the update entry

        .PARAMETER UpdatesAvailable
        All available updates

        .PARAMETER OSVerison
        Operating System to search ofr

        .OUTPUTS
        Custom Object with data

        .EXAMPLE
        Get-UpdateEntry -UpdateAvailable <variable> -OSVersion "10.0.22621"
    #>
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True)]
        $UpdatesAvailable,

        [Parameter(Mandatory=$True)]
        [Int32]
        $OSVersion
    )

    #search for the OSVersion
    foreach($update in $UpdatesAvailable)
    {
        if ($update.OSVersion -eq $OSVersion)
        {
            return $update
        }
    }

    #Return Data
    return New-Object PSCustomObject
}

#Description: Add an update entry
#Function Data:
#   Name:           Add-UpdatePaths
#   Parameters:     OSVersion
#                   OSDescription
#                   KBCU
#                   URICU
#                   KBSafeOS
#                   URISafeOSUpdate
#   Returns:        Custom PSObject
Function Get-WinREData
{
    <#
        .SYNOPSIS
        Get data of WinRE.WIM file

        .DESCRIPTION
        Get data of WinRE.WIM file

        .OUTPUTS
        Custom Object with data

        .EXAMPLE
        Get-WinREData
    #>

    #internal declarations
    $private:winre = New-Object PSCustomObject

    #get WinRE.wim information
    if (-NOT (Test-Path "$env:SystemRoot\System32\Recovery\ReAgent.xml")) {
        Write-Warning "Unable to find $env:SystemRoot\System32\Recovery\ReAgent.xml"
    }
    else 
    {
        [xml]$XmlDocument = Get-content -Path "$env:SystemRoot\System32\Recovery\ReAgent.xml" -Raw
        $XmlDocument.SelectNodes('WindowsRE') | ForEach-Object {
            $local:WinRE_LocationId = $_.WinreLocation.id
            $local:WinRE_LocationOffset = $_.WinreLocation.offset
            $local:WinRE_LocationPath = $_.WinreLocation.path
            $local:WinRE_LocationPartition = (Get-Disk -Number $local:WinRE_LocationId | Get-Partition | Where-Object {$_.Offset -eq $local:WinRE_LocationOffset}).PartitionNumber
            $WinRE_InstallState = $_.InstallState.state
            $WinRE_Enabled = if ($WinRE_InstallState -eq 0) { $false } else { $true }
            $WinRE_IsAutoRepairOn = $_.IsAutoRepairOn.state
            $WinRE_OsBuildVersion = $_.OsBuildVersion.path
            $WinRE_Location = '\\?\GLOBALROOT\device\harddisk' + $local:WinRE_LocationId + '\partition' + $local:WinRE_LocationPartition + $local:WinRE_LocationPath
        }

        #adding the values
        $local:WinREData = (Get-WindowsImage -imagepath (($WinRE_Location).TRIM() + "\winre.wim") -index 1)
        $private:winre | Add-Member -type NoteProperty -Name Enabled -Value $WinRE_Enabled
        $private:winre | Add-Member -type NoteProperty -Name Build -Value $local:WinREData.SPBuild
        $private:winre | Add-Member -type NoteProperty -Name AutoRepairOn -Value $WinRE_IsAutoRepairOn
        $private:winre | Add-Member -type NoteProperty -Name Version -Value $local:WinREData.Version
        $private:winre | Add-Member -type NoteProperty -Name ModifiedTime -Value $local:WinREData.ModifiedTime
        $private:winre | Add-Member -type NoteProperty -Name CreatedTime -Value $local:WinREData.CreatedTime
        $private:winre | Add-Member -type NoteProperty -Name OsBuildVersion -Value $WinRE_OsBuildVersion
        $private:winre | Add-Member -type NoteProperty -Name ImagePath -Value $local:WinREData.ImagePath
        $private:winre | Add-Member -type NoteProperty -Name ImageName -Value $local:WinREData.ImageName
        $private:winre | Add-Member -type NoteProperty -Name ImageExisting -Value ([System.IO.File]::Exists($local:WinREData.ImagePath))
    }

    #Return Data
    return $private:winre
}


#Description: Mount the WinRE offline image
#Function Data:
#   Name:           Invoke-VerifyWinRE
#   Parameters:     WinREPath
#                   MountDir
#                   UpdatePackage
#   Returns:        Boolean
#                   True  = Update Installed
#                   False = Update not Installed
Function Invoke-VerifyWinRE
{
    <#
        .SYNOPSIS
        Mount the WinRE offline image

        .DESCRIPTION
        Mount the WinRE offline image

        .PARAMETER WinREPath
        WinRE settings

        .PARAMETER MountDir
        MountPoint for offline image

        .PARAMETER UpdatePackage
        Update package details

        .EXAMPLE
        Invoke-VerifyWinRE WinREPath <path to WinRE.WIM>
    #>

    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True)]
        [string]
        $WinREPath,

        [Parameter(Mandatory=$True)]
        [string]
        $MountDir,

        [Parameter(Mandatory=$True)]
        $UpdatePackage
    )

    #Set the action preference
    $ProgressPreference = 'SilentlyContinue'        

    try 
    {
        #Check if the local mount point exists
        if (!(Test-Path -PathType Container -Path $MountDir)) 
        { 
            #Create new directory if not existing
            Write-Log -Level INFO -Message " -> Creating mount point <$($MountDir)>"
            New-Item -ItemType Directory -Path $MountDir -Force | Out-Null
        }

        #Mount the WinRE offline image
        if( ( Invoke-Process -Path ReAgentC.exe -Arguments "/mountre /path $($MountDir)" ) -eq 0)
        {
            Write-Log -Level INFO -Message "    -> Mounting Windows RE successful"
        } 
        else 
        {
            throw "    -> Mounting Windows RE Image Failed. Output: $REMountResult"
        }

        #Validate the Update Status
        $KB = ""
        if ($global:DeploymentModeSafeOS)
        {
            $KB = $UpdatePackage.KBSafeOS
        }
        else 
        {
            $KB = $UpdatePackage.KBCU    
        }
        $UpdateStatus = Get-WindowsPackage -Path $MountDir | Where-Object -Property PackageName -like "*$($KB)*" | Where-Object -Property PackageState -eq "Installed"
        Write-Log -Level INFO -Message " -> Installed packages for <$($KB)> found: $($UpdateStatus.Count)"

        #Unmount the WinRE offline image
        Write-Log -Level INFO -Message " -> Dismounting and Discarding Windows RE"
        Dismount-WindowsImage -Path $MountDir -Discard
    }    
    catch 
    {
        #Exit Failure
        Write-Log -Level FATAL -Message "    -> Generic ERROR: $($_)"
        return [boolean]$false
    }

    #Exit
    if ($UpdateStatus.Count -eq 0)
    {
        return [boolean]$false
    }
    else 
    {
        return [boolean]$true    
    }    
}

#Description: Invoke running a process
#Function Data:
#   Name:           Invoke-Process
#   Parameters:     Path, Parameter
#   Returns:        Exit Code
Function Invoke-Process
{
    <#
        .SYNOPSIS
        Invoke running a process

        .DESCRIPTION
        Invoke running a process

        .PARAMETER Path
        Name of the Process

        .PARAMETER Arguments
        Arguments for the call

        .EXAMPLE
        Invoke-Process -Path <name of process> -Arguments <parameters>
    #>

    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True)]
        [string]
        $Path,

        [Parameter(Mandatory=$True)]
        [string]
        $Arguments
    )

    #Set the action preference
    $ProgressPreference = 'SilentlyContinue'  

    #Internal declarations
    $pinfo = New-Object System.Diagnostics.ProcessStartInfo
    $p = New-Object System.Diagnostics.Process

    #Process Parameters
    $pinfo.FileName = $Path
    $pinfo.RedirectStandardError = $True
    $pinfo.RedirectStandardInput = $True
    $pinfo.RedirectStandardOutput = $True
    $pinfo.LoadUserProfile        = $False
    $pinfo.UseShellExecute = $false
    $pinfo.WindowStyle = 'Hidden'
    $pinfo.Arguments = $Arguments    
    $p.StartInfo = $pinfo

    #Start and Wait for Process
    $p.Start() | Out-Null    
    $p.WaitForExit()

    #Return the ExitCode
    return $p.ExitCode
}


##################################################################################################################
####                                    P R O G R A M    P A R A M E T E R S                                  ####
##################################################################################################################

#Debug Mode
$global:DebugMode               = [Boolean]$true

#DeploymentMode
$global:DeploymentModeSafeOS    = [Boolean]$true            #$true = SafeOS update, $false = full cumulative update

#Log File
$global:LogFilePath             = [System.Environment]::ExpandEnvironmentVariables("%TEMP%\Test-WinRE-CVE-2022-41099.log")

#Temporary Data
$MountDir                       = [System.Environment]::ExpandEnvironmentVariables("%SYSTEMDRIVE%\MOUNT")

#Registry Values
$WriteRegCompletion             = $false
$global:RegCompletionCVEHive    = "HKLM"
$global:RegCompletionCVEPath    = "SOFTWARE\Microsoft\CVE"
$global:RegCompletionCVEName    = "CVE-2022-41099"

#Available Updates for CVE-2022-41099
$global:Updates = @()
$global:Updates += Add-UpdatePaths -OSVersion 22621 -OSDescription "Windows 11 22H2 - Build 22621" -FixedWithBuild 1105 -KBCU "KB5022303" -URICU "https://catalog.s.download.windowsupdate.com/d/msdownload/update/software/crup/2023/01/windows11.0-kb5022609-x64_1f5e0fd80fdd08e541903b0d2d845d5b88bee2b4.cab" -KBSafeOS "KB5022609" -URISafeOS "https://catalog.s.download.windowsupdate.com/d/msdownload/update/software/crup/2023/01/windows11.0-kb5022609-x64_1f5e0fd80fdd08e541903b0d2d845d5b88bee2b4.cab"
$global:Updates += Add-UpdatePaths -OSVersion 22000 -OSDescription "Windows 11 21H2 - Build 22000" -FixedWithBuild 1455 -KBCU "KB5022287" -URICU "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021040-x64_2216fe185502d04d7a420a115a53613db35c0af9.cab" -KBSafeOS "KB5021040" -URISafeOS "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021040-x64_2216fe185502d04d7a420a115a53613db35c0af9.cab"
$global:Updates += Add-UpdatePaths -OSVersion 19045 -OSDescription "Windows 10 22H2 - Build 19045" -FixedWithBuild 2486 -KBCU "KB5022282" -URICU "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021043-x64_efa19d2d431c5e782a59daaf2d04d026bb8c8e76.cab" -KBSafeOS "KB5021043" -URISafeOS "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021043-x64_efa19d2d431c5e782a59daaf2d04d026bb8c8e76.cab"
$global:Updates += Add-UpdatePaths -OSVersion 19044 -OSDescription "Windows 10 21H2 - Build 19044" -FixedWithBuild 2486 -KBCU "KB5022282" -URICU "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021043-x64_efa19d2d431c5e782a59daaf2d04d026bb8c8e76.cab" -KBSafeOS "KB5021043" -URISafeOS "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021043-x64_efa19d2d431c5e782a59daaf2d04d026bb8c8e76.cab"
$global:Updates += Add-UpdatePaths -OSVersion 19043 -OSDescription "Windows 10 21H1 - Build 19043" -FixedWithBuild 2364 -KBCU "KB5021233" -URICU "https://catalog.s.download.windowsupdate.com/d/msdownload/update/software/secu/2022/12/windows10.0-kb5021233-x64_4b20e15fe6e4cf264be4651f95395e8980684a17.cab" -KBSafeOS "KB5021043" -URISafeOS "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021043-x64_efa19d2d431c5e782a59daaf2d04d026bb8c8e76.cab"
$global:Updates += Add-UpdatePaths -OSVersion 19042 -OSDescription "Windows 10 20H2 - Build 19042" -FixedWithBuild 2486 -KBCU "KB5022282" -URICU "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021043-x64_efa19d2d431c5e782a59daaf2d04d026bb8c8e76.cab" -KBSafeOS "KB5021043" -URISafeOS "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021043-x64_efa19d2d431c5e782a59daaf2d04d026bb8c8e76.cab"
$global:Updates += Add-UpdatePaths -OSVersion 17763 -OSDescription "Windows 10 1809 - Build 17763" -FixedWithBuild 3887 -KBCU "KB5022286" -URICU "https://catalog.s.download.windowsupdate.com/d/msdownload/update/software/secu/2023/01/windows10.0-kb5022286-x64_6e84985d215be67ce1395cb2627b5ee68cf4dcb6.msu" -KBSafeOS "KB5021042" -URISafeOS "https://catalog.s.download.windowsupdate.com/d/msdownload/update/software/crup/2022/11/windows10.0-kb5021042-x64_19bb9778b2098cc038a03d3c40f4a16bd80e69d3.cab"
$global:Updates += Add-UpdatePaths -OSVersion 14393 -OSDescription "Windows 10 1607 - Build 14393" -FixedWithBuild 5648 -KBCU "KB5022289" -URICU "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/secu/2023/01/windows10.0-kb5022289-x64_79d8b59c2bea46d286f2960920c075f416446445.msu" -KBSafeOS "KB5021039" -URISafeOS "https://catalog.s.download.windowsupdate.com/c/msdownload/update/software/crup/2022/11/windows10.0-kb5021039-x64_c6da7558fda35928213772e4e552f2360076e683.cab"

#Error and Exit Codes
$global:ERROR_SUCCESS                               = 0     #in this case: UNPATCHED
$global:ERROR_ALREADY_PATCHED                       = 1
$global:ERROR_NO_WINRE_DETECTED                     = 2
$global:ERROR_UNKNOWN                               = 1000
$global:ERROR_PREREQ_FAILURE                        = 1599
$global:ERROR_PATCH_PACKAGE_UNSUPPORTED             = 1627
$global:ERROR_PATCH_NO_SEQUENCE                     = 1648
$global:ERROR_SUCCESS_REBOOT_REQUIRED               = 3010
$Rewrite_ERROR_ALREADY_PATCHED_to_ERROR_SUCCESS     = $false
$Rewrite_ERROR_NO_WINRE_DETECTED_to_ERROR_SUCCESS   = $false

#Setting Security Protocol for .Net Framework to use TLS1.2...
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12


##################################################################################################################
####                                 P R O G R A M    S E Q U E N C E   C O D E                               ####
##################################################################################################################

#Program Start
$Starttime = Get-Date
$ExitCode  = $global:ERROR_SUCCESS

#Debug Output of Program Start
Write-Log -Level INFO -Message "##################################################################################################################"
Write-Log -Level INFO -Message "####                            P R O G R A M    S E Q U E N C E   S T A R T                                  ####"
Write-Log -Level INFO -Message "##################################################################################################################"
Write-Log -Level INFO -Message "Configuration Parameters"
Write-Log -Level INFO -Message " -> Debug Mode                : $($global:DebugMode)"
Write-Log -Level INFO -Message " -> Priorized Offline Mode    : $($global:PriorizedOfflineMode)"
Write-Log -Level INFO -Message " -> Priorized Offline Path    : $($global:PriorizedOfflinePath)"
Write-Log -Level INFO -Message " -> Deployment SafeOS Package : $($global:DeploymentModeSafeOS)"

#Get Details of WinRE.WIM file
$WinRE_Current = Get-WinREData
Write-WinReDebugOutput -WinRE $WinRE_Current

#Check for Exit Conditions
$tmpReturnCodeExitConditions = Test-ExitConditions
if ($tmpReturnCodeExitConditions -eq -1)
{
    #Debug Output
    Write-Log -Level INFO -Message "<Exit Condition> tests successfully completed..."

    #Get Details of OS
    $OSVersion = (Get-CimInstance Win32_OperatingSystem).Version
    $OSBuildNumber = (Get-CimInstance Win32_OperatingSystem).BuildNumber
    Write-Log -Level INFO -Message "Current Operating System"
    Write-Log -Level INFO -Message " -> Version  : $($OSVersion)"

    #Internal Error Handling
    #If image path found, then try to patch
    if( ($WinRE_Current.ImagePath.Length -gt 0) -and ($WinRE_Current.ImageExisting))
    {
        try 
        {
            #Get the required update package
            $UpdatePackage = Get-UpdateEntry -UpdatesAvailable $global:Updates -OSVersion $OSBuildNumber

            #Check for fixed version
            Write-Log -Level FATAL -Message "WinRE Build Version Verification"
            Write-Log -Level FATAL -Message " -> WinRE Version: $($WinRE_Current.Build)"
            Write-Log -Level FATAL -Message " -> Fixed Version: $($UpdatePackage.FixedWithBuild)"
            if ( $UpdatePackage.FixedWithBuild -le $WinRE_Current.Build )
            {
                $ExitCode = $ERROR_ALREADY_PATCHED; 
                throw "WinRE already updated"                
            }
            else 
            {
                Write-Log -Level FATAL -Message " -> WinRE not updated via Cumulative Update"
            }

            #Verify the WinRE.WIM offline image
            Write-Log -Level INFO -Message "Verify the local WinRE offline image"
            if(!(Invoke-VerifyWinRE -WinREPath $WinRE_Current.ImagePath -MountDir $MountDir -UpdatePackage $UpdatePackage ))
            {
                #Error Handling
                $ExitCode = $global:ERROR_PATCH_UPDATE_FAILED
                throw "Aborting WinRE update process"
            }
            else 
            {
                Write-Log -Level FATAL -Message " -> Update found in local WinRE image"   
                $ExitCode = $global:ERROR_ALREADY_PATCHED
            }
        }    
        catch 
        {
            Write-Log -Level FATAL -Message " -> ERROR: $($_)"    
            if($ExitCode -eq 0) 
            { 
                $ExitCode = $global:ERROR_UNKNOWN 
            }           

            if (Test-Path -PathType Container -Path ($MountDir + "\Windows")) 
            { 
                Write-Log -Level INFO -Message "Dismounting Windows RE due to it is still mounted. Discarding changes."
                Dismount-WindowsImage -Path $MountDir -Discard
            }
        }    

        #Clean-up tasks
        Write-Log -Level INFO -Message "Cleaning up files and directories"
        if (Test-Path -PathType Container -Path $MountDir) 
        { 
            Write-Log -Level INFO -Message " -> Removing directory <$($MountDir)>"
            Remove-Item -Path $MountDir -Force 
        }

        #Write Patching Result to Registry
        if (($ExitCode -eq $ERROR_SUCCESS -or $ExitCode -eq $ERROR_ALREADY_PATCHED) -and $WriteRegCompletion)
        {
            Write-Log -Level INFO -Message "Creating completion event in the System Registry"
            $tmpRegistryPath = $global:RegCompletionCVEHive + ":\" + $global:RegCompletionCVEPath
            If ( !(Test-Path $tmpRegistryPath) ) { New-Item -Path $tmpRegistryPath -Force -ErrorAction SilentlyContinue | Out-Null }
            New-ItemProperty -Path $tmpRegistryPath -Name $global:RegCompletionCVEName -Value 1 -ErrorAction SilentlyContinue -PropertyType DWord -Force | Out-Null
            Write-Log -Level INFO -Message " -> Successfully created"
        }
    }
    else 
    {
        Write-Log -Level INFO -Message "Windows Recovery Environment not found. No actions required."
        $ExitCode = $global:ERROR_NO_WINRE_DETECTED
    }
}
else
{
    #0    = ERROR_SUCCESS#                   
    #1627 = ERROR_PATCH_PACKAGE_UNSUPPORTED
    #3010 = ERROR_SUCCESS_REBOOT_REQUIRED 
    #9999 = Already Patched
    if ($tmpReturnCodeExitConditions -eq 1627) { Write-Log -Level FATAL -Message "    ERROR_PATCH_PACKAGE_UNSUPPORTED";    $ExitCode = $global:ERROR_PATCH_PACKAGE_UNSUPPORTED; }
    if ($tmpReturnCodeExitConditions -eq 3010) { Write-Log -Level FATAL -Message "    ERROR_SUCCESS_REBOOT_REQUIRED";      $ExitCode = $global:ERROR_SUCCESS_REBOOT_REQUIRED; }
    if ($tmpReturnCodeExitConditions -eq 9999) { Write-Log -Level FATAL -Message "    ERROR_ALREADY_PATCHED";              $ExitCode = $global:ERROR_ALREADY_PATCHED; }
    if ($ExitCode -eq -1)                      { Write-Log -Level FATAL -Message "    ERROR_PREREQ_FAILURE";               $ExitCode = $global:ERROR_PREREQ_FAILURE; }
    if ($ExitCode -eq -2)                      { Write-Log -Level FATAL -Message "    ERROR_ALREADY_PATCHED";              $ExitCode = $global:ERROR_ALREADY_PATCHED; }
}


##################################################################################################################
####                                           P R O G R A M   E N D                                           ###
##################################################################################################################

#Program End
$Endtime = Get-Date
$Duration = $Endtime - $Starttime
Write-Log -Level INFO -Message "Program Sequene End [Duration: $Duration]" 


##################################################################################################################
####                                           E X I T  C O D E S                                              ###
##################################################################################################################
<#
    0    = ERROR_SUCCESS
    1    = ERROR_UNKNOWN
    1599 = ERROR_PREREQ_FAILURE
    1627 = ERROR_PATCH_PACKAGE_UNSUPPORTED
    1648 = ERROR_PATCH_NO_SEQUENCE
    3010 = ERROR_SUCCESS_REBOOT_REQUIRED
    9999 = ERROR_ALREADY_PATCHED
#>

if($Rewrite_ERROR_ALREADY_PATCHED_to_ERROR_SUCCESS) {$ExitCode = $ERROR_SUCCESS}
if($Rewrite_ERROR_NO_WINRE_DETECTED_to_ERROR_SUCCESS) {$ExitCode = $ERROR_SUCCESS}
Write-Log -Level INFO -Message " -> Exit code: $ExitCode"
exit $ExitCode
